using ImGuiNET;
using Microsoft.Xna.Framework;
using SoulsAssetPipeline.Animation;
using SoulsAssetPipeline.Animation.SIBCAM;
using SoulsAssetPipeline.FLVERImporting;
using SoulsFormats;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NMatrix = System.Numerics.Matrix4x4;
using NVector2 = System.Numerics.Vector2;
using NVector3 = System.Numerics.Vector3;
using NVector4 = System.Numerics.Vector4;
using NQuaternion = System.Numerics.Quaternion;
using DSAnimStudio.TaeEditor;
using DSAnimStudio.ImguiOSD;
using NAudio.Wave;

namespace DSAnimStudio
{
    public static class _QuickDebug
    {

        static string SplineFixCfg_BoneName = "RArm22";
        static string SplineFixCfg_CounterBoneName = "RArm22";
        static int SplineFixCfg_StartFrame = 0;
        static int SplineFixCfg_EndFrame = 0;

        static string SplineFixCfg_BoneName2 = "RArmPalm";
        static string SplineFixCfg_CounterBoneName2 = "RArm22";
        static int SplineFixCfg_StartFrame2 = -1;
        static int SplineFixCfg_EndFrame2 = -1;

        static TAE.Template templateDS1 = null;

        static Dictionary<int, List<bool>> DummyPolySelected = new Dictionary<int, List<bool>>();

        static int BassTestHandle;

        class FieldEntryPerGame
        {
            public string ValueType;
            public int BitCountAfterColon;
            public int ArrayLength;
            public int ByteOffset;
            public int BitOffset;

            public string GetOutputStr(string fieldName)
            {
                return $"[Byte:{ByteOffset.ToString("X4")}{(BitOffset >= 0 ? $"|Bit:{BitOffset}]" : "]      ")} {ValueType} {fieldName}{(BitCountAfterColon > 0 ? $":{BitCountAfterColon}" : "")}{(ArrayLength > 1 ? $"[{ArrayLength}]" : "")}";
            }

            public FieldEntryPerGame(FullFieldInfoForOneGame info)
            {
                ValueType = info.ValueType;
                BitCountAfterColon = info.BitCountAfterColon;
                ArrayLength = info.ArrayLength;
                ByteOffset = info.ByteOffset;
                BitOffset = info.BitOffset;
            }
        }

        class FieldEntry
        {
            public FieldEntryPerGame Bloodborne = null;
            public FieldEntryPerGame DarkSoulsIII = null;
            public FieldEntryPerGame DarkSoulsIISOTFS = null;
            public FieldEntryPerGame DarkSoulsPTDE = null;
            public FieldEntryPerGame DemonsSouls = null;
            public FieldEntryPerGame EldenRing = null;
            public FieldEntryPerGame Sekiro = null;
        }

        static Dictionary<string, Dictionary<string, FieldEntry>> _paramsFields = new Dictionary<string, Dictionary<string, FieldEntry>>();

        static FieldEntry RegistField(string paramName, string fieldName)
        {
            if (!_paramsFields.ContainsKey(paramName))
                _paramsFields.Add(paramName, new Dictionary<string, FieldEntry>());

            if (!_paramsFields[paramName].ContainsKey(fieldName))
                _paramsFields[paramName].Add(fieldName, new FieldEntry());

            return _paramsFields[paramName][fieldName];
        }

        class FullFieldInfoForOneGame
        {
            public string ParamName;
            public string ValueType;
            public string Name;
            public int ArrayLength;
            public int ByteOffset;
            public int BitOffset;

            public int BitCountAfterColon;
            public FullFieldInfoForOneGame(string fileLine)
            {
                var split = fileLine.Split('|');
                ParamName = split[0];
                ValueType = split[1];
                Name = split[2];
                BitCountAfterColon = int.Parse(split[3]);
                ArrayLength = int.Parse(split[4]);
                ByteOffset = int.Parse(split[5]);
                BitOffset = int.Parse(split[6]);
            }
        }

        static List<FullFieldInfoForOneGame> ReadFieldInfos(string fileName)
        {
            List<FullFieldInfoForOneGame> list = new List<FullFieldInfoForOneGame>();
            string[] textLines = File.ReadAllLines(fileName);
            for (int i = 2; i < textLines.Length; i++)
                list.Add(new FullFieldInfoForOneGame(textLines[i]));
            return list;
        }

        public static void BuildDebugMenu()
        {
            var mainScreen = Main.TAE_EDITOR;
            if (templateDS1 == null)
                templateDS1 = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS1.xml"));

            if (DebugTestButton("PARAM OFFSET MASSIVE DUMP THING"))
            {
                var bb = ReadFieldInfos(@"E:\DarkSoulsModding\ParamFieldOffsets_Bloodborne.md");
                var ds3 = ReadFieldInfos(@"E:\DarkSoulsModding\ParamFieldOffsets_DarkSoulsIII.md");
                //var ds2sotfs = ReadFieldInfos(@"E:\DarkSoulsModding\ParamFieldOffsets_DarkSoulsIISOTFS.md");
                var ptde = ReadFieldInfos(@"E:\DarkSoulsModding\ParamFieldOffsets_DarkSoulsPTDE.md");
                var des = ReadFieldInfos(@"E:\DarkSoulsModding\ParamFieldOffsets_DemonsSouls.md");
                var er = ReadFieldInfos(@"E:\DarkSoulsModding\ParamFieldOffsets_EldenRing.md");
                var sdt = ReadFieldInfos(@"E:\DarkSoulsModding\ParamFieldOffsets_Sekiro.md");

                foreach (var x in bb)
                    RegistField(x.ParamName, x.Name).Bloodborne = new FieldEntryPerGame(x);

                foreach (var x in ds3)
                    RegistField(x.ParamName, x.Name).DarkSoulsIII = new FieldEntryPerGame(x);

                //foreach (var x in ds2sotfs)
                //    RegistField(x.ParamName, x.Name).DarkSoulsIISOTFS = new FieldEntryPerGame(x);

                foreach (var x in ptde)
                    RegistField(x.ParamName, x.Name).DarkSoulsPTDE = new FieldEntryPerGame(x);

                foreach (var x in des)
                    RegistField(x.ParamName, x.Name).DemonsSouls = new FieldEntryPerGame(x);

                foreach (var x in er)
                    RegistField(x.ParamName, x.Name).EldenRing = new FieldEntryPerGame(x);

                foreach (var x in sdt)
                    RegistField(x.ParamName, x.Name).Sekiro = new FieldEntryPerGame(x);


                foreach (var paramKvp in _paramsFields)
                {
                    var sb = new StringBuilder();

                    var reorderedKeyValuePairs = paramKvp.Value.OrderBy(x => x.Key);

                    foreach (var fieldKvp in reorderedKeyValuePairs)
                    {
                        sb.AppendLine($"{paramKvp.Key}.{fieldKvp.Key}:");
                        if (fieldKvp.Value.Bloodborne != null)
                            sb.AppendLine("           BB: " + fieldKvp.Value.Bloodborne.GetOutputStr(fieldKvp.Key));
                        if (fieldKvp.Value.DarkSoulsIII != null)
                            sb.AppendLine("          DS3: " + fieldKvp.Value.DarkSoulsIII.GetOutputStr(fieldKvp.Key));
                        //if (fieldKvp.Value.DarkSoulsIISOTFS != null)
                        //    sb.AppendLine("    DS2_SOTFS: " + fieldKvp.Value.DarkSoulsIISOTFS.GetOutputStr(fieldKvp.Key));
                        if (fieldKvp.Value.DarkSoulsPTDE != null)
                            sb.AppendLine("     DS1_PTDE: " + fieldKvp.Value.DarkSoulsPTDE.GetOutputStr(fieldKvp.Key));
                        if (fieldKvp.Value.DemonsSouls != null)
                            sb.AppendLine("          DES: " + fieldKvp.Value.DemonsSouls.GetOutputStr(fieldKvp.Key));
                        if (fieldKvp.Value.EldenRing != null)
                            sb.AppendLine("           ER: " + fieldKvp.Value.EldenRing.GetOutputStr(fieldKvp.Key));
                        if (fieldKvp.Value.Sekiro != null)
                            sb.AppendLine("          SDT: " + fieldKvp.Value.Sekiro.GetOutputStr(fieldKvp.Key));
                        sb.AppendLine();
                    }
                    if (!Directory.Exists($@"{Main.Directory}\PARAM_OFFSETS_DUMP"))
                        Directory.CreateDirectory($@"{Main.Directory}\PARAM_OFFSETS_DUMP");
                    File.WriteAllText($@"{Main.Directory}\PARAM_OFFSETS_DUMP\{paramKvp.Key}.txt", sb.ToString());
                }

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("GCCollect"))
            {
                GC.Collect(0, GCCollectionMode.Forced, false);
                GC.Collect(1, GCCollectionMode.Forced, false);
                GC.Collect(2, GCCollectionMode.Forced, false);
            }

            string getByteString(byte[] bytes)
            {
                return string.Join(" ", bytes.Select(b => b.ToString("X2")));
            }

            if (DebugTestButton("NF_MultiplyBoneMotion_Breakpoint"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var boneIndexToMessWith = Scene.MainModel.AnimContainer.Skeleton.HkxSkeleton.FindIndex(b => b.Name.ToLowerInvariant() == "master");

                if (boneIndexToMessWith == -1)
                {
                    Console.WriteLine("breakpoint");
                }

                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        var trackIndex = anim.HkxBoneIndexToTransformTrackMap[boneIndexToMessWith];



                        var baseRotation = anim.Frames[0].RootMotionRotation;
                        var baseTranslation = anim.Frames[0].RootMotionTranslation;
                        for (int f = 0; f < anim.Frames.Count; f++)
                        {
                            var frame = anim.Frames[f];
                            var tr = frame.BoneTransforms[trackIndex];

                            // Do shit to transform
                            tr.Translation *= new NVector3(1, 2.5f, 1);


                            frame.BoneTransforms[trackIndex] = tr;
                            anim.Frames[f] = frame;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("breakpoint");
            }

            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();

            var taePrintSb = new StringBuilder();
            if (DebugTestButton("++++ GENERAL PURPOSE TAE SCAN ++++"))
            {
                Console.WriteLine("breakpoint");
                //var template = TAE.Template.ReadXMLFile($"{Main.Directory}\\Res\\TAE.Template.DS3.xml");
                //var anibnds = Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game_Unpacked\chr", "*.anibnd.dcx");
                var template = TAE.Template.ReadXMLFile($"{Main.Directory}\\Res\\TAE.Template.ER.xml");
                var anibnds = Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\Elden Ring\Game\chr", "*.anibnd.dcx");
                foreach (var anibndName in anibnds)
                {
                    bool anibndHasEvent = false;
                    var bnd = BND4.Read(anibndName);
                    var taeFiles = bnd.Files.Where(x => TAE.Is(x.Bytes));
                    foreach (var t in taeFiles)
                    {
                        
                        var tae = TAE.Read(t.Bytes);
                        tae.ApplyTemplate(template);
                        foreach (var anim in tae.Animations)
                        {
                            foreach (var ev in anim.Events)
                            {

                                if (ev.Type == 601)
                                {
                                    //taePrintSb.AppendLine($"'{anibndName}' - '{t.Name}' - Event 601 found");
                                    anibndHasEvent = true;
                                }
                                    

                            }
                        }
                    }

                    if (anibndHasEvent)
                    {
                        taePrintSb.AppendLine($"'{Path.GetFileName(anibndName)}' - Event 601 found");
                    }
                }

                if (File.Exists("DEBUG - TAE PRINT.txt"))
                    File.Delete("DEBUG - TAE PRINT.txt");
                File.WriteAllText("DEBUG - TAE PRINT.txt", taePrintSb.ToString());
                Console.WriteLine();
            }


            if (DebugTestButton("Scan all chrbnd"))
            {
                int highestBonesPerMesh = 0;
                string meshHighestBonesAreIn = "";
                var chrbnds = Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\chr", "*.chrbnd.dcx");
                foreach (var chrbndName in chrbnds)
                {
                    var bnd = BND4.Read(chrbndName);
                    var flverFiles = bnd.Files.Where(x => FLVER2.Is(x.Bytes));
                    foreach (var t in flverFiles)
                    {
                        var f = FLVER2.Read(t.Bytes);
                        int meshIndex = 0;
                        foreach (var m in f.Meshes)
                        {
                            List<int> bonesWeightedTo = new List<int>();
                            foreach (var v in m.Vertices)
                            {
                                for (int i = 0; i < 4; i++)
                                {
                                    if (!bonesWeightedTo.Contains(v.BoneIndices[i]))
                                        bonesWeightedTo.Add(v.BoneIndices[i]);
                                }
                            }
                            if (bonesWeightedTo.Count > highestBonesPerMesh)
                            {
                                meshHighestBonesAreIn = $"{Path.GetFileName(t.Name)} - Mesh {meshIndex}";
                                highestBonesPerMesh = bonesWeightedTo.Count;
                            }
                            meshIndex++;
                        }
                    }
                }

                Console.WriteLine();
            }



            if (DebugTestButton("hash blast"))
            {
                var strings = new string[]
                {
                    "AvgDistForWall",
                    "AvgDistMaxForIndoor",
                    "AvgDistMaxForUG",
                    "azimuth",
                    "BgmVolume",
                    "Center_MatRatio_Grass",
                    "Center_MatRatio_Swamp",
                    "Center_MatRatio_Water",
                    "Distance",
                    "DistanceFromDummyPoint_03",
                    "Doppler",
                    "elavation",
                    "FrontLeft_MatRatio_Grass",
                    "FrontLeft_MatRatio_Swamp",
                    "FrontLeft_MatRatio_Water",
                    "FrontRight_MatRatio_Grass",
                    "FrontRight_MatRatio_Swamp",
                    "FrontRight_MatRatio_Water",
                    "IngameMasterVolume",
                    "IsBuddy",
                    "IsChrSilence",
                    "IsMenuDisplayedForVoice",
                    "IsPlayingCutScene",
                    "IsPlayingMovie",
                    "MasterVolume",
                    "MaterialHardness",
                    "NoHitNum",
                    "OutdoorIndoor",
                    "PlayerMoveSpeed",
                    "PlayerPosHeight_Legacy",
                    "PlayerPosHeight_Open",
                    "RearLeft_MatRatio_Grass",
                    "RearLeft_MatRatio_Swamp",
                    "RearLeft_MatRatio_Water",
                    "RearRight_MatRatio_Grass",
                    "RearRight_MatRatio_Swamp",
                    "RearRight_MatRatio_Water",
                    "ReverbType",
                    "RoomType",
                    "SeVolume",
                    "TimeOfDay",
                    "VoiceVolume",
                    "WindStrength",
                    "# 1645612461",
                    "# 195788603",
                    "# 247135359",
                    "# 1645612460",
                    "# 809178969",


                    "AttackStrength",
                    "AttackType",
                    "CommonPlaceType",
                    "DamageAmount",
                    "DeffensiveMaterial",
                    "EasyOcclusionID",
                    "FallenLeaves",
                    "FieldBattleState",
                    "FieldBgmSilent",
                    "GrassHitType",
                    "HitStop",
                    "IsVisibleRetryDialog",
                    "LoopCheck",
                    "OffensiveMaterial",
                    "OutdoorIndoor",
                    "OutdoorIndoorForEnv",
                    "OutdoorIndoorForRain",
                    "PlayerEquipmentBottoms",
                    "PlayerEquipmentTops",
                    "PlayerMoveSpeed",
                    "PlayerShoes",
                    "Set_State_EnvPlaceType",
                    "Set_State_PlayerState",
                    "StateWeatherType",
                    "TimeZone",
                    "TreeBurning",
                    "WaterDepthFootSE",

                    "_000_Iron",
                    "_000_Silence",
                    "_001_Leather",
                    "_001_StonePavement",
                    "_002_Stone",
                    "_002_Wood",
                    "_003_Dirt",
                    "_003_Flesh",
                    "_004_Stone",
                    "_004_Timber",
                    "_005_Grass",
                    "_006_Gravel",
                    "_006_None",
                    "_007_Magma",
                    "_008_Wood",
                    "_009_Swamp",
                    "_00_Sunny",
                    "_01",
                    "_010_nest",
                    "_011_Iron",
                    "_012_FleshAndBlood",
                    "_013_Sand",
                    "_014_Bone",
                    "_015_Ash",
                    "_017_Cloth",
                    "_018_FallenLeaves",
                    "_019_Bell",
                    "_01_ClearSky",
                    "_01_Small",
                    "_02",
                    "_020_Paddle",
                    "_021_Water",
                    "_022_WaterKnee",
                    "_023_PoisonSwamp",
                    "_024_PoisonSwampDeep",
                    "_025_PoisonSwampKnee",
                    "_026_PoisonSwampPaddle",
                    "_027_WaterWaist",
                    "_028_Carpet",
                    "_029_None",
                    "_03",
                    "_030_Eclipse",
                    "_031",
                    "_032_Cloud",
                    "_033_Abyss",
                    "_034_Glass",
                    "_035_Maggot",
                    "_040",
                    "_041",
                    "_042",
                    "_043_Snow",
                    "_044_Mud",
                    "_045_Ice",
                    "_0_Cut",
                    "_0_Small",
                    "_1",
                    "_100_IronWeapon",
                    "_101_Mercury",
                    "_102_WoodWeapon",
                    "_103_FleshWeapon",
                    "_104_IronShield",
                    "_105_WoodShield",
                    "_106_Iron",
                    "_107_DriedFlesh",
                    "_108_LeatherArmor",
                    "_109_Flesh",
                    "_10_WeakCloudy",
                    "_110_FleshWeakness",
                    "_111_FleshWeaknessHuge",
                    "_112_HeavyIron",
                    "_113_Cloth",
                    "_114_Rune",
                    "_115_RuneWeakness",
                    "_116_StoneSoft",
                    "_117_Stone",
                    "_118_Mud",
                    "_119_LavaWeakness",
                    "_11_Cloudy",
                    "_120_Lava",
                    "_121_Spirit",
                    "_122_Crystal",
                    "_123_Shell",
                    "_124_Bone",
                    "_125_Carapace",
                    "_126_SpiritWeakness",
                    "_127_StoneShield",
                    "_128_Wood",
                    "_129_HeavyIronShield",
                    "_130_WhiteGhost",
                    "_134_Shadow",
                    "_135_WGhostGuard",
                    "_139_None",
                    "_140_OldMetal",
                    "_141_ShadowWeakness",
                    "_142_SpiritGeneral",
                    "_143_SpiritGeneralWeakness",
                    "_144_ChainMail",
                    "_145_BodyFluid",
                    "_146_BodyFluidWeakness",
                    "_147_Rotten",
                    "_148_RottenWeakness",
                    "_149_IronWeapon_Light",
                    "_150_IronWeapon_Middle",
                    "_151114",
                    "_151_IronWeapon_Heavy",
                    "_152_WoodWeapon_Heavy",
                    "_153_StoneWeapon",
                    "_154_StoneWeapon_Light",
                    "_155_StoneWeapon_Heavy",
                    "_156_MercuryWeapon",
                    "_157_CrystalWeapon",
                    "_158_LetterWeapon",
                    "_159_FingerWeapon",
                    "_160_IronShield_Light",
                    "_161_WoodShield_Heavy",
                    "_162_StoneShield_Heavy",
                    "_163_CrystalShield",
                    "_164_GhostShield",
                    "_165_MercuryHard",
                    "_166_MalikethRobe",
                    "_167_MalikethArmor",
                    "_168_MassiveUniverse",
                    "_171_Scale",
                    "_172_ScaleWeakness",
                    "_173_ScaleWeaknessHuge",
                    "_174_HardScale",
                    "_1_Big",
                    "_1_On",
                    "_1_Pierce",
                    "_20",
                    "_20_Paddle",
                    "_20_Rain",
                    "_21_HeavyRain",
                    "_22",
                    "_24",
                    "_2_Hit",
                    "_2_Repel",
                    "_30_Storm",
                    "_31_StormForBattle",
                    "_40_Snow",
                    "_41_HeavySnow",
                    "_50_Fog",
                    "_51_HeavyFog",
                    "_52_HeavyFogRain",
                    "_60_SandStorm",
                    "_81_SnowStorm",
                    "_82_LightningStorm",
                    "_83_Reserved",
                    "_84_Reserved",
                    "_85_Reserved",
                    "_86_Reserved",
                    "_87_Reserved",
                    "_88_Reserved",
                    "Armour",
                    "Barefoot",
                    "Boots",
                    "Burning_petit",
                    "ChainMail",
                    "Cloth",
                    "Env_000_Green",
                    "Env_010_Lake",
                    "Env_020_Mountain",
                    "Env_030_Plain",
                    "Env_040_Snow",
                    "Env_100_Castle",
                    "Env_110_KingCity",
                    "Env_120_UgLabyrinth",
                    "Env_130_Remains",
                    "Env_140_Academy",
                    "Env_150_RottenBigTree",
                    "Env_160_VolcanoPrison",
                    "Env_180_Tutorial",
                    "Env_190_Ritual",
                    "Env_300_Catacombs",
                    "Env_310_Cave",
                    "Env_320_Tunnel",
                    "Env_340_Tower",
                    "Env_350_UgKingCity",
                    "Env_390_CliffTunnel",
                    "Env_500_Fortress",
                    "Fast",
                    "FieldBattle",
                    "FieldNormal",
                    "HitNormal",
                    "IndoorAll",
                    "IndoorHalf",
                    "LeatherArmour",
                    "NightTime",
                    "No",
                    "Normal",
                    "NotHit",
                    "Nude",
                    "On",
                    "Outdoor",
                    "PlayerCrouching",
                    "PlayerResting",
                    "Slow",
                    "Yes",
                    "# 1616602882",
                    "# 2037129417",
                    "# 4272577682",
                    "# 2135765449",
                    "# 2599511129",
                    "# 1429115003",
                    "# 2816836770",
                    "# 653005191",
                    "Play_s000450590",
                    "PlayerVoice",
"StateWeatherType",
"_00_PC_Male_Young_Neutral",
"_01_PC_Male_Young_Deeper",
"_02_PC_Male_Mature_Neutral",
"_03_PC_Male_Mature_Deeper",
"_04_PC_Male_Aged_Neutral",
"_05_PC_Male_Aged_Deeper",
"_10_PC_Female_Young_Neutral",
"_11_PC_Female_Young_Deeper",
"_12_PC_Female_Mature_Neutral",
"_13_PC_Female_Mature_Deeper",
"_14_PC_Female_Aged_Neutral",
"_15_PC_Female_Aged_Deeper",
"_30_Storm",
"_31_StormForBattle",
"_50_NPC_Male_Young",
"_51_NPC_Male_Middle",
"_52_NPC_Male_Old",
"_60_NPC_Female_Young",
"_60_SandStorm",
"_61_NPC_Female_Middle",
"_62_NPC_Female_Old",
"_81_SnowStorm",
"_82_LightningStorm",
"NPC_vc300",
"NPC_vc301",
"NPC_vc302",
"NPC_vc303",
"NPC_vc304",
"NPC_vc305",
"NPC_vc306",
"NPC_vc307",
"NPC_vc308",
"NPC_vc309",
"NPC_vc310",
"NPC_vc311",
"NPC_vc312",
"NPC_vc313",
"NPC_vc314",
"NPC_vc316",
"NPC_vc318",
"NPC_vc319",
"NPC_vc320",
"NPC_vc321",
"NPC_vc322",
"NPC_vc323",
"NPC_vc324",
"NPC_vc325",
"NPC_vc326",
"NPC_vc331",
"NPC_vc332",
"NPC_vc333",
"NPC_vc334",
"NPC_vc335",
"NPC_vc337",
"NPC_vc341",
"NPC_vc348",
"NPC_vc349",
"NPC_vc351",
"NPC_vc352",
"NPC_vc400",
"NPC_vc401",
                };

                foreach (var s in strings)
                    System.Diagnostics.Debug.WriteLine($"{s} --> {Wwise.FnvHash(s)}");

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("Wwise all banks scan"))
            {
                var bankFiles = System.IO.Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\sound", "*.bnk", SearchOption.AllDirectories);
                foreach (var bnkFile in bankFiles)
                {
                    var shortName = Utils.GetShortIngameFileName(bnkFile);
                    using (var bnk = SoulsAssetPipeline.Audio.Wwise.WwiseBNK.Read(File.ReadAllBytes(bnkFile)))
                    {
                        System.Diagnostics.Debug.WriteLine($"Bank '{shortName}' is version {bnk.BKHD.BankGeneratorVersion}");
                    }
                }

                Console.WriteLine("fatcat");
            }



            if (DebugTestButton("Wwise BNK Test"))
            {
                var bnk = SoulsAssetPipeline.Audio.Wwise.WwiseBNK.Read(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\sound\enus\cs_c2130.bnk");

                Console.WriteLine("fatcat");

                //Wwise.PlaySoundInBank("cs_c2130", "Play_c213006000", () => Vector3.Zero, -1, -1, false, null);



                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("WEM load test"))
            {
                var wemFile = File.ReadAllBytes(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\sound\wem\10\104016490.wem");
                //var oggBytes = WEMFile.ConvertWEMtoOGG(wemFile, WEMForcePacketFormat.NoForcePacketFormat);

                //var ms = new MemoryStream(wemFile);
                //var wem = new Anki.AudioKinetic.WEMReader(ms);
                //wem.Open();
                //var waveOut = new NAudio.Wave.WaveOut();
                //var waveProvider = wem.WaveProvider();
                //var samp = waveProvider.ToSampleProvider();
                //var test = new VarispeedDemo.SoundTouch.VarispeedSampleProvider(samp, 100, new VarispeedDemo.SoundTouch.SoundTouchProfile(false, true));
                //test.PlaybackRate = 2;
                ////var smb = new SMBPitchShiftingSampleProvider(waveProvider.ToSampleProvider(), 4096, 4L, 2);
                ////waveOut.Init(smb);
                //waveOut.Init(test);
                //waveOut.Play();



                //File.WriteAllBytes(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\sound\wem\10\104016490.wem.ogg", oggBytes);

                Console.WriteLine("FUCK");
            }

            if (DebugTestButton("Wwise FNV Hash Test"))
            {
                var hash = Wwise.FnvHash("Play_c213001000");

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("DX11 TEST"))
            {
                GameRoot.Init("test.txt", SoulsAssetPipeline.SoulsGames.DS3, @"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game");
                Main.TEST_DX11FLVER = new DX11FlverRenderer(FLVER2.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c5280-chrbnd-dcx\chr\c5280\c5280.flver"));
            }

            if (DebugTestButton("HIDE RIGHT WEAPON"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {


                    },
                    (fixer, anim) =>
                    {
                        int masterBoneIndex = -1;
                        for (int t = 0; t < fixer.TargetSkeleton.HkxSkeleton.Count; t++)
                        {
                            if (fixer.TargetSkeleton.HkxSkeleton[t].Name == "R_Weapon")
                            {
                                masterBoneIndex = t;
                                break;
                            }
                        }
                        if (masterBoneIndex >= 0)
                        {
                            int masterTransformTrack = anim.HkxBoneIndexToTransformTrackMap[masterBoneIndex];
                            if (masterTransformTrack >= 0)
                            {
                                for (int f = 0; f < anim.FrameCount; f++)
                                {
                                    var tr = anim.Frames[f].BoneTransforms[masterTransformTrack];
                                    tr.Scale = NVector3.Zero;
                                    anim.Frames[f].BoneTransforms[masterTransformTrack] = tr;
                                }
                            }
                        }
                    })

                });

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("SHOW RIGHT WEAPON"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        int masterBoneIndex = -1;
                        for (int t = 0; t < fixer.TargetSkeleton.HkxSkeleton.Count; t++)
                        {
                            if (fixer.TargetSkeleton.HkxSkeleton[t].Name == "R_Weapon")
                            {
                                masterBoneIndex = t;
                                break;
                            }
                        }
                        if (masterBoneIndex >= 0)
                        {
                            int masterTransformTrack = anim.HkxBoneIndexToTransformTrackMap[masterBoneIndex];
                            if (masterTransformTrack >= 0)
                            {
                                for (int f = 0; f < anim.FrameCount; f++)
                                {
                                    var tr = anim.Frames[f].BoneTransforms[masterTransformTrack];
                                    tr.Scale = NVector3.One;
                                    anim.Frames[f].BoneTransforms[masterTransformTrack] = tr;
                                }
                            }
                        }
                    })

                });



                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("fatcat");
            }


            if (DebugTestButton("HIDE LEFT WEAPON"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        int masterBoneIndex = -1;
                        for (int t = 0; t < fixer.TargetSkeleton.HkxSkeleton.Count; t++)
                        {
                            if (fixer.TargetSkeleton.HkxSkeleton[t].Name == "L_Weapon")
                            {
                                masterBoneIndex = t;
                                break;
                            }
                        }
                        if (masterBoneIndex >= 0)
                        {
                            int masterTransformTrack = anim.HkxBoneIndexToTransformTrackMap[masterBoneIndex];
                            if (masterTransformTrack >= 0)
                            {
                                for (int f = 0; f < anim.FrameCount; f++)
                                {
                                    var tr = anim.Frames[f].BoneTransforms[masterTransformTrack];
                                    tr.Scale = NVector3.Zero;
                                    anim.Frames[f].BoneTransforms[masterTransformTrack] = tr;
                                }
                            }
                        }
                    })

                });

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("SHOW LEFT WEAPON"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        int masterBoneIndex = -1;
                        for (int t = 0; t < fixer.TargetSkeleton.HkxSkeleton.Count; t++)
                        {
                            if (fixer.TargetSkeleton.HkxSkeleton[t].Name == "L_Weapon")
                            {
                                masterBoneIndex = t;
                                break;
                            }
                        }
                        if (masterBoneIndex >= 0)
                        {
                            int masterTransformTrack = anim.HkxBoneIndexToTransformTrackMap[masterBoneIndex];
                            if (masterTransformTrack >= 0)
                            {
                                for (int f = 0; f < anim.FrameCount; f++)
                                {
                                    var tr = anim.Frames[f].BoneTransforms[masterTransformTrack];
                                    tr.Scale = NVector3.One;
                                    anim.Frames[f].BoneTransforms[masterTransformTrack] = tr;
                                }
                            }
                        }
                    })

                });

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("UNFUCK MASTER AND ROOT"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;

                List<Vector3> rootMotionData = new List<Vector3>();

                splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        for (int i = 0; i < anim.FrameCount; i++)
                            rootMotionData.Add(anim.Frames[i].RootMotionTranslation);
                    })

                }); ;

                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                        int masterBoneIndex = -1;
                        for (int t = 0; t < fixer.TargetSkeleton.HkxSkeleton.Count; t++)
                        {
                            if (fixer.TargetSkeleton.HkxSkeleton[t].Name == "Master")
                            {
                                masterBoneIndex = t;
                                break;
                            }
                        }
                        if (masterBoneIndex >= 0)
                        {
                            var startMasterTransform = fixer.GetTargetFKTransform(0, masterBoneIndex);
                            for (int f = 1; f < curAnim.FrameCount; f++)
                            {
                                var tr = fixer.GetTargetFKTransform(f, masterBoneIndex);
                                tr.Translation = new NVector3(startMasterTransform.Translation.X + rootMotionData[f].X, tr.Translation.Y, startMasterTransform.Translation.Z + rootMotionData[f].Z);
                                fixer.SetTargetFKTransform(f, masterBoneIndex, tr);
                            }
                        }

                    },
                    (fixer, anim) =>
                    {

                        var startRootMotionTransform = anim.Frames[0].RootMotionTranslation;

                        for (int f = 1; f < anim.FrameCount; f++)
                        {
                            anim.Frames[f].RootMotionTranslation = new NVector3(startRootMotionTransform.X, anim.Frames[f].RootMotionTranslation.Y, startRootMotionTransform.Z);
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("DX11 shader meme"))
            {
                DX11Shader.TEST();
            }

            if (DebugTestButton("ER shader metaparam"))
            {
                //var shaderbdleFiles = new string[]
                //{
                //    //@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\shader\speedtree_[rt].shaderbdlebnd.dcx",
                //    @"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\shader\shaderbdle.shaderbdlebnd.dcx",
                //    @"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\shader\shaderbdle.shaderbdlebnd.devpatch.dcx",
                //    @"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\shader\shaderbdle_[rt].shaderbdlebnd.dcx",
                //    //@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\shader\speedtree.shaderbdlebnd.dcx",
                //};
                //foreach (var shaderbdleFile in shaderbdleFiles)
                //{
                //    Directory.CreateDirectory("DSAS_METAPARAM_DUMP");
                //    var bnd = BND4.Read(shaderbdleFile);
                //    foreach (var file in bnd.Files)
                //    {
                //        if (!file.Name.ToLower().EndsWith(".shaderbdle"))
                //            continue;
                //        var innerBnd = BND4.Read(file.Bytes);
                //        foreach (var f in innerBnd.Files)
                //        {
                //            if (f.Name.ToLower().EndsWith(".metaparam"))
                //            {
                //                var shortName = Utils.GetShortIngameFileName(f.Name);
                //                File.WriteAllBytes(@$"DSAS_METAPARAM_DUMP\{shortName}.metaparam", f.Bytes);
                //            }
                //        }
                //    }
                //}

                var metaparamFiles = Directory.GetFiles(@"C:\Users\Green\source\repos\DSAnimStudioNETCore\DSAnimStudioNETCore\bin\x64\Debug\net5.0-windows\DSAS_METAPARAM_DUMP");
                foreach (var m in metaparamFiles)
                {
                    var bin = new SoulsFormats.BinaryReaderEx(false, File.ReadAllBytes(m));
                    bin.AssertASCII("SMD\0");
                    bin.AssertInt32(0);
                    bin.AssertInt32(6);
                }

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("ER censored names meme mod"))
            {
                var dir = @"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\msg\engus";
                var ngwordMsgbnd = BND4.Read(@$"{dir}\ngword.msgbnd.dcx");
                var ngwordFmg = FMG.Read(ngwordMsgbnd.Files[0].Bytes);
                var ngword = ngwordFmg.Entries.Select(f => f.Text).Where(f => !string.IsNullOrWhiteSpace(f)).ToList();

                string processString(string str)
                {
                    string checkNgwordEntry(string s, string n)
                    {
                        if (n.Length > s.Length)
                            return s;
                        string res = s;
                        int matchIndex = -1;
                        do
                        {
                            matchIndex = res.ToLower().IndexOf(n.ToLower());
                            if (matchIndex >= 0)
                            {
                                var arr = res.ToCharArray();
                                for (int i = 0; i < n.Length; i++)
                                {
                                    arr[matchIndex + i] = '*';
                                }
                                res = new string(arr);
                            }
                        }
                        while (matchIndex >= 0);

                        return res;
                    }
                    string res = str;
                    foreach (var n in ngword)
                    {
                        res = checkNgwordEntry(res, n);
                        var trimmed = n.Trim();
                        if (n != trimmed)
                            res = checkNgwordEntry(res, trimmed);
                    }
                    return res;
                }

                void processMsgbnd(string msgbndPath, string outputMsgbndPath)
                {
                    var debugShortName = Path.GetFileName(msgbndPath);

                    var mbnd = BND4.Read(msgbndPath);
                    for (int i = 0; i < mbnd.Files.Count; i++)
                    {
                        var fmg = FMG.Read(mbnd.Files[i].Bytes);

                        for (int j = 0; j < fmg.Entries.Count; j++)
                        {
                            Console.WriteLine($@"{debugShortName}[{i}/{mbnd.Files.Count}][{j}/{fmg.Entries.Count}]");
                            if (!String.IsNullOrWhiteSpace(fmg.Entries[j].Text))
                                fmg.Entries[j].Text = processString(fmg.Entries[j].Text);
                        }

                        mbnd.Files[i].Bytes = fmg.Write();
                    }
                    mbnd.Write(outputMsgbndPath);
                }

                if (!Directory.Exists($@"{dir}\meme"))
                    Directory.CreateDirectory($@"{dir}\meme");
                processMsgbnd($@"{dir}\item.msgbnd.dcx", $@"{dir}\meme\item.msgbnd.dcx");
                processMsgbnd($@"{dir}\menu.msgbnd.dcx", $@"{dir}\meme\menu.msgbnd.dcx");

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("ER TAE Param Size Scan"))
            {
                var anibndFiles = Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\chr", "*.anibnd.dcx");

                // Nested Dict { EventID, { byteCount, numInstances } }
                Dictionary<int, Dictionary<int, int>> paramSizes = new Dictionary<int, Dictionary<int, int>>();

                Dictionary<int, Dictionary<int, bool[]>> assert0Bytes = new Dictionary<int, Dictionary<int, bool[]>>();

                void RegistParamByteCountInst(int evType, byte[] paramBytes)
                {
                    if (!paramSizes.ContainsKey(evType))
                        paramSizes.Add(evType, new Dictionary<int, int>());

                    if (!paramSizes[evType].ContainsKey(paramBytes.Length))
                        paramSizes[evType].Add(paramBytes.Length, 0);

                    paramSizes[evType][paramBytes.Length] += 1;



                    if (!assert0Bytes.ContainsKey(evType))
                        assert0Bytes.Add(evType, new Dictionary<int, bool[]>());

                    if (!assert0Bytes[evType].ContainsKey(paramBytes.Length))
                    {
                        assert0Bytes[evType].Add(paramBytes.Length, new bool[paramBytes.Length]);
                        for (int i = 0; i < paramBytes.Length; i++)
                        {
                            assert0Bytes[evType][paramBytes.Length][i] = true;
                        }
                    }

                    for (int i = 0; i < paramBytes.Length; i++)
                    {
                        if (paramBytes[i] != 0)
                            assert0Bytes[evType][paramBytes.Length][i] = false;
                    }
                }

                foreach (var anibndFile in anibndFiles)
                {
                    var bnd = BND4.Read(anibndFile);
                    var taeFiles = bnd.Files.Where(f => f.Name.ToLower().EndsWith(".tae")).ToList();
                    foreach (var t in taeFiles)
                    {
                        var tae = TAE.Read(t.Bytes);
                        foreach (var a in tae.Animations)
                        {
                            foreach (var ev in a.Events)
                            {
                                var paramBytes = ev.GetParameterBytes(false);
                                RegistParamByteCountInst(ev.Type, paramBytes);
                            }
                        }
                    }
                }

                bool[] getAssert0(int eventType, int byteCount)
                {
                    if (assert0Bytes.ContainsKey(eventType))
                        if (assert0Bytes[eventType].ContainsKey(byteCount))
                            return assert0Bytes[eventType][byteCount];

                    return null;
                }

                var sb = new StringBuilder();

                foreach (var kvp in paramSizes.OrderBy(k => k.Key))
                {
                    var test = TAE.Template.ReadXMLFile("Res/TAE.Template.ER.xml");
                    var bank = test[35];

                    int byteCountInTemplate = -1;

                    if (bank.ContainsKey(kvp.Key))
                    {
                        byteCountInTemplate = bank[kvp.Key].GetAllParametersByteCount();
                    }

                    sb.AppendLine($"[EVENT {kvp.Key}]");
                    foreach (var pair_ByteCount_InstCount in kvp.Value)
                    {
                        var assertCheck = getAssert0(kvp.Key, pair_ByteCount_InstCount.Key);

                        sb.AppendLine($"    [{pair_ByteCount_InstCount.Key} Bytes] [{pair_ByteCount_InstCount.Value} Instances] Assert Mask: {(string.Join(' ', assertCheck.Select(s => s ? "00" : "XX")))}");
                    }
                }

                File.WriteAllText("MEOW_DEBUG_ER_EVENT_DUMP.txt", sb.ToString());

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("ER Write FMG Compare Meme"))
            {
                void DoFMG(string fmgPath)
                {
                    var fmg = FMG.Read(fmgPath);

                    var jpn = FMG.Read(fmgPath.Replace("engus", "jpnjp").Replace("engUS", "jpnJP"));
                    var eng = FMG.Read(fmgPath);
                    var lines = new List<string>();

                    List<int> idsDone = new List<int>();
                    void Check(int id)
                    {
                        if (!idsDone.Contains(id) && (string.IsNullOrWhiteSpace(eng[id]) != string.IsNullOrWhiteSpace(jpn[id])))
                        {
                            lines.Add($"{id} | {(eng[id] ?? "%null%")} | {(jpn[id] ?? "%null%")} | ");
                            idsDone.Add(id);
                        }
                    }
                    foreach (var e in fmg.Entries)
                        Check(e.ID);

                    lines = lines.OrderBy(x => x).ToList();

                    var sb = new StringBuilder();
                    sb.AppendLine($"ID | English | Japanese | Japanese Translated to English");
                    sb.AppendLine($"--- | --- | --- | ---");
                    foreach (var ln in lines)
                        sb.AppendLine(ln);

                    File.WriteAllText(fmgPath + ".unused.txt", sb.ToString());
                }

                var fmgs = Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\msg\engus\menu-msgbnd-dcx\GR\data\INTERROOT_win64\msg\engUS\", "*.fmg");
                foreach (var f in fmgs)
                    DoFMG(f);

                Console.WriteLine("Fatcat");
            }

            if (DebugTestButton("ER_TestPlaySoundInject"))
            {
                EldenRingSoundInject.PlaySound(10000, 1, 102360000);
            }

            if (DebugTestButton("NF_iceKingShit"))
            {
                Console.WriteLine("Fatcat");

                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                        //for (int f = 0; f < curAnim.FrameCount; f++)
                        //{
                        //    List<NewBlendableTransform> origFkTransforms = new List<NewBlendableTransform>();
                        //    for (int b = 0; b < Scene.MainModel.AnimContainer.Skeleton.HkxSkeleton.Count; b++)
                        //    {
                        //        origFkTransforms.Add(fixer.GetTargetFKTransform(f, b));
                        //    }
                        //    for (int b = 0; b < Scene.MainModel.AnimContainer.Skeleton.HkxSkeleton.Count; b++)
                        //    {
                        //        fixer.SetTargetFKTransform(f, b, new NewBlendableTransform(NMatrix.CreateRotationY(MathHelper.PiOver2)) * origFkTransforms[b]);
                        //    }
                        //    //var origFk0 = fixer.GetTargetFKTransform(f, 0);
                        //    //var origFk1 = fixer.GetTargetFKTransform(f, 1);
                        //    //fixer.SetTargetFKTransform(f, 0, origFk0 * new NewBlendableTransform(NMatrix.CreateRotationY(MathHelper.PiOver2)));
                        //    //fixer.SetTargetFKTransform(f, 1, origFk1 * new NewBlendableTransform(NMatrix.CreateRotationY(MathHelper.PiOver2)));
                        //}
                    },
                    (fixer, anim) =>
                    {

                        for (int f = 0; f < anim.Frames.Count; f++)
                        {
                            anim.Frames[f].BoneTransforms[0] = new NewBlendableTransform(NMatrix.CreateRotationY(-MathHelper.Pi)) * anim.Frames[f].BoneTransforms[0];
                            anim.Frames[f].RootMotionTranslation = NVector3.Transform(anim.Frames[f].RootMotionTranslation, NMatrix.CreateRotationY(-MathHelper.Pi));
                        }

                        anim.Frames.Add(new SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame());
                        anim.Frames[anim.Frames.Count - 1].BoneTransforms = anim.Frames[0].BoneTransforms;
                        anim.Frames[anim.Frames.Count - 1].RootMotionTranslation = anim.Frames[anim.Frames.Count - 2].RootMotionTranslation + (anim.Frames[anim.Frames.Count - 2].RootMotionTranslation - anim.Frames[anim.Frames.Count - 3].RootMotionTranslation);
                        anim.FrameCount++;
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("Fatcat");
            }

            if (DebugTestButton("DeS_HyperArmorDump"))
            {

            }

            if (DebugTestButton("NF Bloodlust ID Reassign"))
            {
                int correctAnimID(int animID)
                {
                    var splitID = GameRoot.SplitAnimID.FromFullID(animID);
                    if (splitID.SubID >= 5000 && splitID.SubID <= 5099)
                    {
                        splitID.SubID = 5600 + (splitID.SubID % 1_00);
                    }
                    else if (splitID.SubID >= 5300 && splitID.SubID <= 5399)
                    {
                        splitID.SubID = 5700 + (splitID.SubID % 1_00);
                    }
                    return splitID.GetFullID();
                }

                foreach (var tae in mainScreen.FileContainer.AllTAE)
                {
                    foreach (var a in tae.Animations)
                    {
                        if (!string.IsNullOrWhiteSpace(a.AnimFileName) && a.AnimFileName.StartsWith("+"))
                        {
                            a.ID = correctAnimID((int)a.ID);
                            if (a.MiniHeader is TAE.Animation.AnimMiniHeader.ImportOtherAnim asImporOtherAnim)
                                asImporOtherAnim.ImportFromAnimID = correctAnimID(asImporOtherAnim.ImportFromAnimID);
                            else if (a.MiniHeader is TAE.Animation.AnimMiniHeader.Standard asStandard)
                                asStandard.ImportHKXSourceAnimID = correctAnimID(asStandard.ImportHKXSourceAnimID);
                        }

                        foreach (var e in a.Events)
                        {
                            if (e.TypeName == "NF_SwapUpcomingAnimID")
                            {
                                e.Parameters["From"] = correctAnimID(Convert.ToInt32(e.Parameters["From"]));
                                e.Parameters["To"] = correctAnimID(Convert.ToInt32(e.Parameters["To"]));
                            }
                            else if (e.TypeName == "QueueTransitionAnimation")
                            {
                                e.Parameters["Destination Anim ID"] = correctAnimID(Convert.ToInt32(e.Parameters["Destination Anim ID"]));
                                e.Parameters["Transition Anim ID"] = correctAnimID(Convert.ToInt32(e.Parameters["Transition Anim ID"]));
                            }
                        }
                    }
                }

                Console.WriteLine("TEST");
            }

            if (DebugTestButton("NF_SifCurvedSwordAnimFix"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                        int weaponBoneIndex = -1;
                        for (int t = 0; t < fixer.TargetSkeleton.HkxSkeleton.Count; t++)
                        {

                            if (fixer.TargetSkeleton.HkxSkeleton[t].Name== "Wep")
                            {
                                weaponBoneIndex = t;
                            }
                        }

                        //const int frInStart = 6;
                        //const int frInEnd = 13;
                        //const int frOutStart = 80;
                        //const int frOutEnd = 90;
                        //const float rotDirMultInStart = 0;
                        //const float rotDirMultMidst = 1;
                        //const float rotDirMultOutEnd = 0;

                        //const int frInStart = 5;
                        //const int frInEnd = 9;
                        //const int frOutStart = 57;
                        //const int frOutEnd = 63;
                        //const float rotDirMultInStart = 0;
                        //const float rotDirMultMidst = 1;
                        //const float rotDirMultOutEnd = 0;

                        //const int frInStart = 28;
                        //const int frInEnd = 35;
                        //const int frOutStart = 73;
                        //const int frOutEnd = 80;
                        //const float rotDirMultInStart = 0;
                        //const float rotDirMultMidst = -1;
                        //const float rotDirMultOutEnd = 0;

                        const int frInStart = 5;
                        const int frInEnd = 9;
                        const int frOutStart = 37;
                        const int frOutEnd = 43;
                        const float rotDirMultInStart = 0;
                        const float rotDirMultMidst = -1;
                        const float rotDirMultOutEnd = 0;

                        float rotDirMult = 1;

                        //var baseRotation = anim.Frames[0].RootMotionRotation;
                        //var baseTranslation = anim.Frames[0].RootMotionTranslation;
                        for (int f = frInStart; f <= frOutEnd; f++)
                        {

                            float ratio = 0;

                            if (f <= frInEnd)
                            {
                                ratio = Math.Max(0, Math.Min(1f, ((float)f - (float)frInStart) / ((float)frInEnd - (float)frInStart)));
                                rotDirMult = MathHelper.Lerp(rotDirMultInStart, rotDirMultMidst, ratio);
                            }
                            else if (f >= frOutStart)
                            {
                                ratio = 1f - Math.Max(0, Math.Min(1f, ((float)f - (float)frOutStart) / ((float)frOutEnd - (float)frOutStart)));
                                rotDirMult = MathHelper.Lerp(rotDirMultOutEnd, rotDirMultMidst, ratio);
                            }
                            else
                            {
                                ratio = 1f;
                                rotDirMult = rotDirMultMidst;
                            }

                            var tr = splineFixer.GetTargetFKTransform(f, weaponBoneIndex);
                            tr = tr * NewBlendableTransform.Lerp(NewBlendableTransform.Identity, new NewBlendableTransform((NMatrix.CreateRotationX(MathHelper.Pi * rotDirMult))), ratio);
                            splineFixer.SetTargetFKTransform(f, weaponBoneIndex, tr);
                        }



                    },
                    (fixer, anim) =>
                    {

                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            if (DebugTestButton("elden ring hkx meme"))
            {
                var memes = System.IO.Directory.GetFiles(@"C:\Users\Green\Downloads\_Vivaldi\ER_c0000_DSR", "*.hkx", SearchOption.AllDirectories);
                foreach (var m in memes)
                {
                    var bytes = File.ReadAllBytes(m);
                    bytes[0x2E] = 0x30;
                    File.WriteAllBytes(m, bytes);
                }

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("NF IMPORT TAE"))
            {
                var bbTaeAnibnd = BND4.Read(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c2310.anibnd.dcx");
                var tae = TAE.Read(bbTaeAnibnd.Files.FirstOrDefault(ff => ff.ID == 3000000).Bytes);


                var templateBB = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS3.xml"));

                tae.ApplyTemplate(templateBB);
                var animsToKeep = new List<TAE.Animation>();
                foreach (var anim in tae.Animations)
                {
                    var eventsToKeep = new List<TAE.Event>();
                    foreach (var ev in anim.Events)
                    {
                        ev.Group = null;

                        if (ev.TypeName.Contains("FFX") && ev.Template.ContainsKey("FFXID"))
                        {
                            int ffxid = Convert.ToInt32(ev.Parameters["FFXID"]);
                            //if (ffxid == 654035)
                            //{
                            //    ev.Parameters["FFXID"] = 99542000;
                            //}

                            // SpawnFFX_ByFloorType
                            if (ev.Type == 112)
                            {
                                if (ffxid == 1000200)
                                    ffxid = 1560000;
                                else if (ffxid == 1000300)
                                    ffxid = 1560100;
                            }
                            else if (ffxid == 623106)
                            {
                                ffxid = 99_5600_00;
                            }
                            else
                            {
                                continue;
                            }

                            ev.Parameters["FFXID"] = ffxid;
                        }
                        else if (ev.Type == 0)
                        {
                            int j = Convert.ToInt32(ev.Parameters["JumpTableID"]);
                            if (j == 5) // Get-parried window
                                continue;
                        }
                        else if (ev.Type == 313)
                        {
                            ev.ForceChangeType(7029);
                        }
                        else if (ev.TypeName.Contains("Sound"))
                        {
                            int sid = Convert.ToInt32(ev.Parameters["SoundID"]);
                            if (sid >= 2310_00000 && sid <= 2310_99999)
                            {
                                sid = (sid % 2310_00000) + 5600_00000;
                            }
                        }

                        eventsToKeep.Add(ev);
                    }

                    anim.Events = eventsToKeep;
                    anim.EventGroups.Clear();

                    int upper = (int)(anim.ID / 1_000000);
                    int lower = (int)(anim.ID % 1_000000);
                    if (lower > 9999)
                        continue;
                    anim.ID = (upper * 1_0000) + (lower);

                    animsToKeep.Add(anim);
                }

                tae.Animations = animsToKeep;

                tae.BigEndian = false;
                tae.Format = TAE.TAEFormat.DS1;

                tae.ChangeTemplateAfterLoading(templateDS1, 0);

                tae.Write(@"E:\DarkSoulsModding_Nightfall\c5600.tae");

                Console.WriteLine("Fatcat");
            }


            if (false && DebugTestButton("m99_88_88_88.msb meme"))
            {
                var msb = MSB1.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\map\MapStudio\m99_88_88_88.msb");
                msb.Parts.Enemies.Clear();
                msb.Models.Enemies.Clear();
                msb.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\map\MapStudio\m99_88_88_88.msb");
                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("NF_ExtractRootMotionXFromMasterX"))
            {
                Console.WriteLine("Fatcat");

                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        int memeTrackIndex = -1;

                        var skeleton = Scene.MainModel.AnimContainer.Skeleton;

                        var baseFrameTransforms = new List<NewBlendableTransform>();
                        for (int t = 0; t < anim.Frames[0].BoneTransforms.Count; t++)
                        {
                            if (anim.TransformTrackNames[t] == "Master")
                            {
                                memeTrackIndex = t;
                            }

                            var hkxBone = skeleton.HkxSkeleton.FirstOrDefault(b => b.Name == anim.TransformTrackNames[t]);

                            baseFrameTransforms.Add(NewBlendableTransform.Identity);
                        }

                        if (memeTrackIndex == -1)
                        {

                            return;
                        }


                        for (int f = 0; f < anim.Frames.Count; f++)
                        {
                            var tr = anim.Frames[f].BoneTransforms[memeTrackIndex];
                            anim.Frames[f].RootMotionTranslation.X = tr.Translation.X;
                            tr.Translation.X = 0;
                            anim.Frames[f].BoneTransforms[memeTrackIndex] = tr;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, mainScreen.GetAnimListInfoOfAnim(mainScreen.SelectedTaeAnim)?.GetName() ?? Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("Fatcat");
            }

            if (DebugTestButton("NF Quick DarkLordTumor TAE Fixes"))
            {
                var anibnd = BND3.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5410.anibnd.dcx");

                var taeEntry = anibnd.Files.First(f => f.Name.ToLower().EndsWith(".tae"));
                var tae = TAE.Read(taeEntry.Bytes);

                tae.ApplyTemplate(mainScreen.SelectedTae.AppliedTemplate);

                foreach (var anim in tae.Animations)
                {
                    var eventsToDelete = new List<TAE.Event>();
                    var eventsToAdd = new List<TAE.Event>();
                    foreach (var ev in anim.Events)
                    {
                        if (ev.TypeName != null && ev.TypeName.Contains("FFX"))
                        {
                            var ffxid = Convert.ToInt32(ev.Parameters["FFXID"]);
                            if (ffxid >= 1033000 && ffxid <= 1033002)
                                eventsToDelete.Add(ev);
                            else if (ffxid == 1000200)
                                ev.Parameters["FFXID"] = 1541000;
                            else if (ffxid == 1000300)
                                ev.Parameters["FFXID"] = 1541100;
                            else if (ffxid == 251)
                                ev.Parameters["FFXID"] = 260;
                        }
                        else if (ev.TypeName != null && ev.TypeName == "SetTurnSpeed")
                        {
                            if (anim.ID < 700)
                                continue;

                            var turnSpeed = Convert.ToSingle(ev.Parameters["TurnSpeed"]);
                            eventsToDelete.Add(ev);

                            float windowStart = ev.StartTime;
                            float windowEnd = ev.EndTime;
                            float windowLength = ev.EndTime - ev.StartTime;
                            float windowMiddle = TaeExtensionMethods.RoundTimeToCurrentSnapInterval(windowStart + (windowLength / 2f));

                            var newEv_1st = new TAE.Event(windowStart, windowMiddle, 7021, 0, false, mainScreen.SelectedTae.AppliedTemplate[0][7021]);
                            newEv_1st.Parameters["TurnSpeed"] = new NVector2(0, turnSpeed * 2.5f);
                            newEv_1st.Parameters["CurveType"] = (byte)1;
                            eventsToAdd.Add(newEv_1st);

                            var newEv_2nd = new TAE.Event(windowMiddle, windowEnd, 7021, 0, false, mainScreen.SelectedTae.AppliedTemplate[0][7021]);
                            newEv_2nd.Parameters["TurnSpeed"] = new NVector2(2.5f * turnSpeed, 0);
                            newEv_2nd.Parameters["CurveType"] = (byte)1;
                            eventsToAdd.Add(newEv_2nd);
                        }
                        else if (ev.Type == 315)
                        {
                            eventsToDelete.Add(ev);
                            if (ev.EndTime < 30)
                            {
                                var newEv = new TAE.Event(ev.StartTime, ev.EndTime, 7032, 0, false, mainScreen.SelectedTae.AppliedTemplate[0][7032]);
                                newEv.Parameters["Speed"] = new NVector2(1, 2);
                                newEv.Parameters["CurveType"] = (byte)0;
                                eventsToAdd.Add(newEv);
                            }
                        }
                        else if (ev.Type == 316)
                        {
                            eventsToDelete.Add(ev);
                            var newEv = new TAE.Event(ev.StartTime, ev.EndTime, 7032, 0, false, mainScreen.SelectedTae.AppliedTemplate[0][7032]);
                            newEv.Parameters["Speed"] = new NVector2(2, 1);
                            newEv.Parameters["CurveType"] = (byte)0;
                            eventsToAdd.Add(newEv);
                        }
                        else if (ev.Type == 123)
                        {
                            eventsToDelete.Add(ev);
                        }
                        else if (ev.Type == 228)
                        {
                            eventsToDelete.Add(ev);
                        }

                    }

                    foreach (var ev in eventsToDelete)
                    {
                        if (anim.Events.Contains(ev))
                            anim.Events.Remove(ev);
                    }

                    eventsToAdd = eventsToAdd.OrderBy(e => e.Type).ToList();

                    foreach (var ev in eventsToAdd)
                    {
                        anim.Events.Add(ev);
                    }
                }

                taeEntry.Bytes = tae.Write();

                anibnd.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5410.anibnd.dcx");

                Console.WriteLine("poggers");
            }


            if (DebugTestButton("NF_TumorFuckingSutpidShitREeeetwtasfrgadgfhdgh"))
            {
                Console.WriteLine("Fatcat");

                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        int tumorTrackIndex = -1;

                        var skeleton = Scene.MainModel.AnimContainer.Skeleton;

                        var baseFrameTransforms = new List<NewBlendableTransform>();
                        for (int t = 0; t < anim.Frames[0].BoneTransforms.Count; t++)
                        {
                            if (anim.TransformTrackNames[t] == "Tumor_00")
                            {
                                tumorTrackIndex = t;
                            }

                            var hkxBone = skeleton.HkxSkeleton.FirstOrDefault(b => b.Name == anim.TransformTrackNames[t]);

                            baseFrameTransforms.Add(NewBlendableTransform.Identity);
                        }

                        if (tumorTrackIndex == -1)
                        {

                            return;
                        }


                        for (int f = 71; f < anim.Frames.Count; f++)
                        {
                            var tr = anim.Frames[f].BoneTransforms[tumorTrackIndex];
                            tr.Scale = NVector3.One;
                            anim.Frames[f].BoneTransforms[tumorTrackIndex] = tr;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, mainScreen.GetAnimListInfoOfAnim(mainScreen.SelectedTaeAnim)?.GetName() ?? Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.WriteLine("Fatcat");
            }

            if (DebugTestButton("NF_DarkLordTentaclesSpawnAnimEdit"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        //var baseRotation = anim.Frames[0].RootMotionRotation;
                        //var baseTranslation = anim.Frames[0].RootMotionTranslation;
                        for (int f = 0; f < anim.Frames.Count; f++)
                        {
                            //float ratio = Math.Min(1, ((float)f / 25f));
                            //for (int t = 0; t < anim.Frames[f].BoneTransforms.Count; t++)
                            //{
                            //    var tr = anim.Frames[f].BoneTransforms[t];
                            //    tr.Translation *= MathHelper.Lerp(0.1f, 1.0f, ratio);
                            //    tr.Scale *= MathHelper.Lerp(0.5f, 1.0f, ratio);
                            //    anim.Frames[f].BoneTransforms[t] = tr;
                            //}
                            for (int t = 0; t < anim.Frames[f].BoneTransforms.Count; t++)
                            {
                                anim.Frames[f].BoneTransforms[t] = anim.Frames[0].BoneTransforms[t];
                            }
                            anim.Frames[f].RootMotionRotation = 0;
                            anim.Frames[f].RootMotionTranslation = NVector3.Zero;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }


            if (DebugTestButton("NF Sisters Base Anim Imports"))
            {
                var ptdeAnibnd = BND3.Read(@"E:\Program Files (x86)\Steam\steamapps\common\Dark Souls Prepare to Die Edition\DATA\chr\c2400.anibnd");

                foreach (var bf in ptdeAnibnd.Files)
                {
                    if (!bf.Name.ToLower().EndsWith(".hkx"))
                        continue;


                }
            }

            var NF_HotfixAnimRootMotion_MultX = UpdateFloat("NF_HotfixAnimRootMotion_MultX", "NF_HotfixAnimRootMotion_MultX", 1);
            var NF_HotfixAnimRootMotion_MultY = UpdateFloat("NF_HotfixAnimRootMotion_MultY", "NF_HotfixAnimRootMotion_MultY", 1);
            var NF_HotfixAnimRootMotion_MultZ = UpdateFloat("NF_HotfixAnimRootMotion_MultZ", "NF_HotfixAnimRootMotion_MultZ", 1);
            var NF_HotfixAnimRootMotion_MultW = UpdateFloat("NF_HotfixAnimRootMotion_MultW", "NF_HotfixAnimRootMotion_MultW", 1);

            if (DebugTestButton("NF_HotfixAnimRootMotion"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        var baseRotation = anim.Frames[0].RootMotionRotation;
                        var baseTranslation = anim.Frames[0].RootMotionTranslation;
                        for (int f = 0; f < 40; f++)
                        {
                            var frame = anim.Frames[f];
                            frame.RootMotionTranslation -= baseTranslation;
                            frame.RootMotionTranslation *= new NVector3(NF_HotfixAnimRootMotion_MultX, NF_HotfixAnimRootMotion_MultY, NF_HotfixAnimRootMotion_MultZ);
                            frame.RootMotionRotation -= baseRotation;
                            frame.RootMotionRotation *= NF_HotfixAnimRootMotion_MultW;
                            anim.Frames[f] = frame;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            if (false && DebugTestButton("NF Quick DarkLordTentacles TAE Fixes"))
            {
                var anibnd = BND3.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5420.anibnd.dcx");

                var taeEntry = anibnd.Files.First(f => f.Name.ToLower().EndsWith(".tae"));
                var tae = TAE.Read(taeEntry.Bytes);

                foreach (var anim in tae.Animations)
                {
                    foreach (var ev in anim.Events)
                    {
                        if (ev.Type == 122)
                        {
                            ev.ForceChangeType(96);
                            var paramBytes = ev.GetParameterBytes(false);
                            paramBytes[9] = 0;
                            paramBytes[10] = 0;
                            paramBytes[11] = 0;
                            ev.SetParameterBytes(false, paramBytes, true);
                        }
                        else if (ev.Type == 7029)
                        {
                            var paramBytes = ev.GetParameterBytes(false);
                            int currentID = BitConverter.ToInt32(paramBytes, 0);
                            if (currentID == 0)
                                currentID = 10;
                            else if (currentID == 1)
                                currentID = 11;
                            var idBytes = BitConverter.GetBytes(currentID);
                            paramBytes[0] = idBytes[0];
                            paramBytes[1] = idBytes[1];
                            paramBytes[2] = idBytes[2];
                            paramBytes[3] = idBytes[3];
                            ev.SetParameterBytes(false, paramBytes, true);
                        }
                    }
                }

                taeEntry.Bytes = tae.Write();

                anibnd.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5420.anibnd.dcx");

                Console.WriteLine("poggers");
            }

            if (DebugTestButton("Test: Split meshes into 32 bones max"))
            {
                var chrbnd = BND3.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5600.chrbnd.dcx");
                var flverFile = chrbnd.Files.FirstOrDefault(f => f.ID == 200);
                var flver = FLVER2.Read(flverFile.Bytes);

                var meshPool = flver.Meshes.ToList();

                foreach (var m in meshPool)
                {
                    foreach (var v in m.Vertices)
                    {
                        for (int i = 0; i < 4; i++)
                            if (v.BoneIndices[i] == 255 && m.BoneIndices.Count <= 255)
                            {
                                v.BoneIndices[i] = 0;
                                v.BoneWeights[i] = 0;
                            }
                    }
                }

                flver.Meshes.Clear();

                // MAKE BONE INDICES ABSOLUTE
                //foreach (var m in meshPool)
                //{
                //    foreach (var v in m.Vertices)
                //    {
                //        for (int i = 0; i < 4; i++)
                //            v.BoneIndices[i] = m.BoneIndices[v.BoneIndices[i]];
                //    }
                //}



                for (int meshIndex = 0; meshIndex < meshPool.Count; meshIndex++)
                {
                    //var m = meshPool[meshIndex];

                    if (meshPool[meshIndex].BoneIndices.Count < 32)
                    {
                        flver.Meshes.Add(meshPool[meshIndex]);
                        continue;
                    }

                    var fs = meshPool[meshIndex].FaceSets.First(f => f.Flags == FLVER2.FaceSet.FSFlags.None);

                    if (fs.TriangleStrip)
                    {
                        fs.Indices = fs.Triangulate(false);
                        fs.TriangleStrip = false;
                    }

                    FLVER2.Mesh getNewSplitCloneMesh(FLVER2.Mesh m)
                    {
                        var meshClone = new FLVER2.Mesh();
                        //meshClone.BoneIndices = splitMeshBoneIndices[i].OrderBy(x => x).ToList();

                        // TODO: Calculate new bounding box later for polish etc.
                        meshClone.BoundingBox = m.BoundingBox;

                        meshClone.DefaultBoneIndex = m.DefaultBoneIndex;
                        meshClone.Dynamic = m.Dynamic;

                        meshClone.FaceSets.Add(new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.None, false, fs.CullBackfaces, fs.Unk06, new List<int>()));

                        meshClone.MaterialIndex = m.MaterialIndex;
                        foreach (var vb in m.VertexBuffers)
                            meshClone.VertexBuffers.Add(new FLVER2.VertexBuffer(vb.LayoutIndex));

                        return meshClone;
                    }

                    void finalizeSplitCloneMesh(FLVER2.Mesh sm, FLVER2.Mesh m)
                    {
                        var smfs = sm.FaceSets[0];
                        sm.FaceSets.Add(new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.LodLevel1, false, smfs.CullBackfaces, smfs.Unk06, smfs.Indices));
                        sm.FaceSets.Add(new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.LodLevel2, false, smfs.CullBackfaces, smfs.Unk06, smfs.Indices));
                        sm.FaceSets.Add(new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.MotionBlur, false, smfs.CullBackfaces, smfs.Unk06, smfs.Indices));
                        sm.FaceSets.Add(new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.LodLevel1 | FLVER2.FaceSet.FSFlags.MotionBlur, false, smfs.CullBackfaces, smfs.Unk06, smfs.Indices));
                        sm.FaceSets.Add(new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.LodLevel2 | FLVER2.FaceSet.FSFlags.MotionBlur, false, smfs.CullBackfaces, smfs.Unk06, smfs.Indices));

                        //sm.BoneIndices = sm.BoneIndices.OrderBy(x => x).ToList();

                        //List<FLVER.Vertex> processedVertices = new List<FLVER.Vertex>();

                        //for (int v = 0; v < sm.Vertices.Count; v++)
                        //{

                        //    if (!processedVertices.Contains(sm.Vertices[v]))
                        //    {
                        //        for (int j = 0; j < 4; j++)
                        //        {
                        //            int index = sm.BoneIndices.IndexOf(m.BoneIndices[sm.Vertices[v].BoneIndices[j]]);
                        //            if (index < 0)
                        //                Console.WriteLine("WHAT THE FUCK REE");

                        //            sm.Vertices[v].BoneIndices[j] = index;
                        //        }

                        //        processedVertices.Add(sm.Vertices[v]);
                        //    }
                        //}
                    }

                    FLVER2.Mesh currentMesh = getNewSplitCloneMesh(meshPool[meshIndex]);
                    //List<FLVER.Vertex> originalVertsAddedToCurrentMesh = new List<FLVER.Vertex>();
                    List<FLVER2.Mesh> splitMeshes = new List<FLVER2.Mesh>();

                    int vertexIndex = 0;



                    bool vertexMatch(FLVER.Vertex v1, FLVER.Vertex v2)
                    {
                        if (v1.Position != v2.Position)
                            return false;
                        if (v1.Normal != v2.Normal)
                            return false;

                        // Can't compare the indices because of how they'll be different but ehh
                        // this is still a fine check probably lol
                        for (int j = 0; j < 4; j++)
                            if (v1.BoneWeights[j] != v2.BoneWeights[j])
                                return false;

                        return true;
                    }

                    FLVER.Vertex getVertexInstanceFromMesh(FLVER2.Mesh mesh, FLVER.Vertex vert)
                    {
                        foreach (var vv in mesh.Vertices)
                        {
                            if (vertexMatch(vv, vert))
                                return vv;
                        }
                        return null;
                    }

                    bool wouldNextTriangleBeTooManyBones(FLVER2.Mesh m)
                    {
                        if (vertexIndex >= fs.Indices.Count)
                            return false;


                        List<int> additionalIndices = new List<int>();
                        var a = m.Vertices[fs.Indices[vertexIndex]];
                        var b = m.Vertices[fs.Indices[vertexIndex + 1]];
                        var c = m.Vertices[fs.Indices[vertexIndex + 2]];
                        for (int i = 0; i < 4; i++)
                        {
                            if (a.BoneIndices[i] >= 0 && !currentMesh.BoneIndices.Contains(m.BoneIndices[a.BoneIndices[i]]) &&
                                !additionalIndices.Contains(m.BoneIndices[a.BoneIndices[i]]))
                            {
                                additionalIndices.Add(m.BoneIndices[a.BoneIndices[i]]);
                            }
                            if (b.BoneIndices[i] >= 0 && !currentMesh.BoneIndices.Contains(m.BoneIndices[b.BoneIndices[i]]) &&
                                !additionalIndices.Contains(m.BoneIndices[b.BoneIndices[i]]))
                            {
                                additionalIndices.Add(m.BoneIndices[b.BoneIndices[i]]);
                            }
                            if (c.BoneIndices[i] >= 0 && !currentMesh.BoneIndices.Contains(m.BoneIndices[c.BoneIndices[i]]) &&
                                !additionalIndices.Contains(m.BoneIndices[c.BoneIndices[i]]))
                            {
                                additionalIndices.Add(m.BoneIndices[c.BoneIndices[i]]);
                            }
                        }

                        //if (additionalIndices.Count == 0)
                        //    return currentBoneIndices.Count >= 32;

                        return ((currentMesh.BoneIndices.Count + additionalIndices.Count) >= 32);
                    }

                    void consumeTriangle(bool doNotAdvance, FLVER2.Mesh m)
                    {
                        var a = m.Vertices[fs.Indices[vertexIndex]];
                        var aInstance = getVertexInstanceFromMesh(currentMesh, a);
                        if (aInstance == null)
                        {
                            //originalVertsAddedToCurrentMesh.Add(a);


                            int absoluteBoneIndex0 = m.BoneIndices[a.BoneIndices[0]];
                            int absoluteBoneIndex1 = m.BoneIndices[a.BoneIndices[1]];
                            int absoluteBoneIndex2 = m.BoneIndices[a.BoneIndices[2]];
                            int absoluteBoneIndex3 = m.BoneIndices[a.BoneIndices[3]];

                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex0))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex0);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex1))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex1);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex2))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex2);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex3))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex3);

                            a = new FLVER.Vertex(a);
                            currentMesh.Vertices.Add(a);

                            a.BoneIndices[0] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex0);
                            a.BoneIndices[1] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex1);
                            a.BoneIndices[2] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex2);
                            a.BoneIndices[3] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex3);

                            aInstance = a;
                        }




                        var b = m.Vertices[fs.Indices[vertexIndex + 1]];
                        var bInstance = getVertexInstanceFromMesh(currentMesh, b);
                        if (bInstance == null)
                        {
                            //originalVertsAddedToCurrentMesh.Add(b);

                            int absoluteBoneIndex0 = m.BoneIndices[b.BoneIndices[0]];
                            int absoluteBoneIndex1 = m.BoneIndices[b.BoneIndices[1]];
                            int absoluteBoneIndex2 = m.BoneIndices[b.BoneIndices[2]];
                            int absoluteBoneIndex3 = m.BoneIndices[b.BoneIndices[3]];

                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex0))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex0);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex1))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex1);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex2))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex2);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex3))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex3);

                            b = new FLVER.Vertex(b);
                            currentMesh.Vertices.Add(b);

                            b.BoneIndices[0] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex0);
                            b.BoneIndices[1] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex1);
                            b.BoneIndices[2] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex2);
                            b.BoneIndices[3] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex3);

                            bInstance = b;
                        }




                        var c = m.Vertices[fs.Indices[vertexIndex + 2]];
                        var cInstance = getVertexInstanceFromMesh(currentMesh, c);
                        if (cInstance == null)
                        {
                            //originalVertsAddedToCurrentMesh.Add(c);

                            int absoluteBoneIndex0 = m.BoneIndices[c.BoneIndices[0]];
                            int absoluteBoneIndex1 = m.BoneIndices[c.BoneIndices[1]];
                            int absoluteBoneIndex2 = m.BoneIndices[c.BoneIndices[2]];
                            int absoluteBoneIndex3 = m.BoneIndices[c.BoneIndices[3]];

                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex0))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex0);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex1))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex1);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex2))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex2);
                            if (!currentMesh.BoneIndices.Contains(absoluteBoneIndex3))
                                currentMesh.BoneIndices.Add(absoluteBoneIndex3);

                            c = new FLVER.Vertex(c);
                            currentMesh.Vertices.Add(c);

                            c.BoneIndices[0] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex0);
                            c.BoneIndices[1] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex1);
                            c.BoneIndices[2] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex2);
                            c.BoneIndices[3] = currentMesh.BoneIndices.IndexOf(absoluteBoneIndex3);

                            cInstance = c;
                        }

                        currentMesh.FaceSets[0].Indices.Add(currentMesh.Vertices.IndexOf(aInstance));
                        currentMesh.FaceSets[0].Indices.Add(currentMesh.Vertices.IndexOf(bInstance));
                        currentMesh.FaceSets[0].Indices.Add(currentMesh.Vertices.IndexOf(cInstance));

                        if (!doNotAdvance)
                            vertexIndex += 3;
                    }
                    void commitVertices()
                    {
                        splitMeshes.Add(currentMesh);
                        currentMesh = getNewSplitCloneMesh(meshPool[meshIndex]);
                        //originalVertsAddedToCurrentMesh.Clear();
                    }

                    while (vertexIndex < fs.Indices.Count)
                    {
                        if (wouldNextTriangleBeTooManyBones(meshPool[meshIndex]))
                        {
                            commitVertices();
                        }

                        consumeTriangle(doNotAdvance: false, meshPool[meshIndex]);




                    }

                    if (currentMesh.Vertices.Count > 0)
                    {
                        commitVertices();
                    }



                    foreach (var sm in splitMeshes)
                    {
                        finalizeSplitCloneMesh(sm, meshPool[meshIndex]);

                        foreach (var v in sm.Vertices)
                        {
                            for (int i = 0; i < 4; i++)
                            {
                                if (v.BoneIndices[i] < 0)
                                    Console.WriteLine("WHAT THE FUCKING SHIT");
                            }
                        }

                        flver.Meshes.Add(sm);
                    }
                }




                flverFile.Bytes = flver.Write();
                chrbnd.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5600.chrbnd.dcx");

                Console.WriteLine("fatcat?");
            }


            if (DebugTestButton("Test: Output DS1R *.2010 file for current BB chr"))
            {
                var anibndPath = mainScreen.FileContainerName;
                IBinder anibnd = null;
                if (BND3.Is(anibndPath))
                    anibnd = BND3.Read(anibndPath);
                else if (BND4.Is(anibndPath))
                    anibnd = BND4.Read(anibndPath);

                var ac = Scene.MainModel.AnimContainer;
                var allAnimNames = ac.Animations.Keys.ToList();
                foreach (var a in allAnimNames)
                {
                    ac.ChangeToNewAnimation(a, 1, 0, true, false);

                    var splineFixer = new HavokSplineFixer(ac.Skeleton);

                    var curAnim = ac.CurrentAnimation;
                    var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                    {
                        new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                        {
                        },
                        (fixer, anim) =>
                        {
                        })

                    });

                    if (curAnim.IsAdditiveBlend)
                    {
                        fixedAnim.BlendHint = HKX.AnimationBlendHint.ADDITIVE;
                    }

                    var outputAnim = ImportedAnimationConverter.GetAnimReadyToPutIntoGameFromImported(fixedAnim, SoulsAssetPipeline.SoulsGames.DS1);
                    var bndEntry = anibnd.Files.FirstOrDefault(f => f.Name.ToUpper().EndsWith(a.ToUpper()));
                    bndEntry.Bytes = outputAnim.Data2010;

                    bndEntry.ID %= 1000000000;

                    //a000_000000.hkx = 15 characters long xd
                    bndEntry.Name = bndEntry.Name.Substring(0, bndEntry.Name.Length - 15)
                        + GameRoot.SplitAnimID.FromFullID(bndEntry.ID).
                        GetFormattedIDString(SoulsAssetPipeline.SoulsGames.DS1R) + ".hkx";
                }



                if (anibnd is BND3 anibndBND3)
                {
                    anibndBND3.Write(anibndPath + ".2010");
                }
                else if (anibnd is BND4 anibndBND4)
                {
                    var bnd3Output = new BND3();
                    bnd3Output.BigEndian = anibndBND4.BigEndian;
                    bnd3Output.BitBigEndian = anibndBND4.BitBigEndian;
                    bnd3Output.Compression = anibndBND4.Compression;
                    bnd3Output.Format = anibndBND4.Format;
                    bnd3Output.Files = anibndBND4.Files;
                    bnd3Output.Write(anibndPath + ".2010");
                }

                Console.WriteLine("fatcat");
            }

            if (DebugTestButton("Convert BB HKXPWV Test"))
            {
                var hkxpwv = HKXPWV.Read(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c5420-chrbnd-dcx\chr\c5420\c5420_BB.hkxpwv");

                hkxpwv.Game = HKXPWV.GameType.DS1;

                hkxpwv.Write(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c5420-chrbnd-dcx\chr\c5420\c5420.hkxpwv");

                Console.WriteLine("Fatcat");
            }

            if (DebugTestButton("NF_ImportDarkLordTentaclesParams"))
            {
                var parambndBB = BND4.Read(@"E:\PS4\CUSA03173-app\dvdroot_ps4\param\gameparam\gameparam.parambnd.dcx");
                var parambndDS1R = BND3.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\param\GameParam\GameParam_BeforeKing.parambnd.dcx");

                void PortParams(string paramFileName, Func<int, bool> whetherToImportRow, int byteCountBB,
                    int byteCountDS1R, Dictionary<string, string> rowNameReplaceDict, Func<int, int> rowIDReplaceFunc, Action<PARAM_Hack.Row> rowFixAction)
                {
                    var paramFileDS1R = parambndDS1R.Files.First(f => f.Name.ToUpper().Contains(paramFileName.ToUpper()));
                    var paramFileBB = parambndBB.Files.First(f => f.Name.ToUpper().Contains(paramFileName.ToUpper()));

                    var paramDS1R = PARAM_Hack.Read(paramFileDS1R.Bytes);
                    var paramBB = PARAM_Hack.Read(paramFileBB.Bytes);

                    paramDS1R.Hack_ReadGhettoRowData(byteCountDS1R);
                    paramBB.Hack_ReadGhettoRowData(byteCountBB);

                    var rowsToAddToDS1R = new List<PARAM_Hack.Row>();

                    foreach (var row in paramBB.Rows)
                    {
                        if (whetherToImportRow?.Invoke(row.ID) ?? true)
                        {
                            if (rowNameReplaceDict != null)
                            {
                                foreach (var kvp in rowNameReplaceDict)
                                {

                                    row.Name = row.Name.Replace(kvp.Key, kvp.Value);
                                }
                            }
                            row.ID = rowIDReplaceFunc?.Invoke(row.ID) ?? row.ID;
                            Array.Resize(ref row.GhettoDataStorage, byteCountDS1R);
                            rowFixAction?.Invoke(row);
                            rowsToAddToDS1R.Add(row);
                        }
                    }

                    paramDS1R.Rows.AddRange(rowsToAddToDS1R);

                    paramFileDS1R.Bytes = paramDS1R.Write();
                }

                var attackNameReplaceDict = new Dictionary<string, string>
                {
                    { "c2310_青衣の王_片手斬りコンボ1", "c5600_NF_King_1HSlash1" },
                     { "c2310_青衣の王_片手斬りコンボ2", "c5600_NF_King_1HSlash2" },
                     { "c2310_青衣の王_片手斬りコンボ3", "c5600_NF_King_1HSlash3" },
                     { "c2310_青衣の王_両手斬りコンボ1", "c5600_NF_King_2HSlash1" },
                     { "c2310_青衣の王_両手斬りコンボ2", "c5600_NF_King_2HSlash2" },
                     { "c2310_青衣の王_突きコンボ1", "c5600_NF_King_PushCombo1" },
                     { "c2310_青衣の王_突きコンボ2", "c5600_NF_King_PushCombo2" },
                     { "c2310_青衣の王_蹴りコンボ1", "c5600_NF_King_KickCombo1" },
                     { "c2310_青衣の王_蹴りコンボ2", "c5600_NF_King_KickCombo2" },
                     { "c2310_青衣の王_回転斬りコンボ1", "c5600_NF_King_RotateSlashCombo1" },
                     { "c2310_青衣の王_回転斬りコンボ2", "c5600_NF_King_RotateSlashCombo2" },
                     { "c2310_青衣の王_武器強化", "c5600_NF_King_WeaponBuff" },
                     { "c2310_青衣の王_強両手コンボコンボ1", "c5600_NF_King_2HStrongSlash1" },
                     { "c2310_青衣の王_強両手コンボコンボ2", "c5600_NF_King_2HStrongSlash2" },
                     { "c2310_青衣の王_フルパワー兜割", "c5600_NF_King_FullPowerHelmSplitter" },
                     { "c2310_青衣の王_ダッシュ回転斬り", "c5600_NF_King_DashRotateSlash" },
                     { "c2310_青衣の王_片手斬りコンボ1(強化後)", "c5600_NF_King_1HSlash1(BUFFED)" },
                     { "c2310_青衣の王_片手斬りコンボ2(強化後)", "c5600_NF_King_1HSlash2(BUFFED)" },
                     { "c2310_青衣の王_片手斬りコンボ3(強化後)", "c5600_NF_King_1HSlash3(BUFFED)" },
                     { "c2310_青衣の王_両手斬りコンボ1(強化後)", "c5600_NF_King_2HSlash1(BUFFED)" },
                     { "c2310_青衣の王_両手斬りコンボ2(強化後)", "c5600_NF_King_2HSlash2(BUFFED)" },
                     { "c2310_青衣の王_突きコンボ1(強化後)", "c5600_NF_King_PushCombo1(BUFFED)" },
                     { "c2310_青衣の王_突きコンボ2(強化後)", "c5600_NF_King_PushCombo2(BUFFED)" },
                     { "c2310_青衣の王_蹴りコンボ1(強化後)", "c5600_NF_King_KickCombo1(BUFFED)" },
                     { "c2310_青衣の王_蹴りコンボ2(強化後)", "c5600_NF_King_KickCombo2(BUFFED)" },
                     { "c2310_青衣の王_回転斬りコンボ1(強化後)", "c5600_NF_King_RotateSlashCombo1(BUFFED)" },
                     { "c2310_青衣の王_回転斬りコンボ2(強化後)", "c5600_NF_King_RotateSlashCombo2(BUFFED)" },
                     { "c2310_青衣の王_衝撃", "c5600_NF_King_WeaponSwingBullet" },
                    { "（", "(" },
                    { "）", ")" },
                    { "悪夢を継ぐ者", "DarkLord" },
                    { "その場ラッシュ", "StationaryRush" },
                    { "ひっくり返る", "FlipOver" },
                    { "突進ラッシュ", "ChargeRush" },
                    { "空中プレス", "AerialSlam" },
                    { "最終形態", "Tentacles" },
                    { "左面攻撃", "LeftSideAtk" },
                    { "右面攻撃", "RightSideAtk" },
                    { "這いずる", "Crawl" },
                    { "背面攻撃", "RearAttack" },
                    { "空中魔法", "AoE" },
                    { "衝突", "Whack" },
                    { "空中", "Midair" },
                    { "触手", "Tentacle" },
                    { "右腕", "RightArm" },
                    { "左腕", "LeftArm" },
                    { "地上", "OnGround" },
                    { "右手", "RightHand" },
                    { "左手", "LeftHand" },
                    { "弾丸", "Bullet" },
                    { "体", "Body" },


                };


                PortParams("NpcParam", r => (r == 2310_00),
                    byteCountBB: 388, byteCountDS1R: 336,
                    rowNameReplaceDict: attackNameReplaceDict,
                    rowIDReplaceFunc: id => 5600_00, row =>
                    {
                        var variationIdBytes = BitConverter.GetBytes(56000);
                        var aiThinkIDBytes = BitConverter.GetBytes(5600_00);

                        for (int i = 0; i < 4; i++)
                        {
                            row.GhettoDataStorage[i] = variationIdBytes[i];
                            row.GhettoDataStorage[i + 0x4] = aiThinkIDBytes[i];
                        }
                    }
                    );

                PortParams("NpcThinkParam", r => (r == 2310_00),
                    byteCountBB: 148, byteCountDS1R: 112,
                    rowNameReplaceDict: attackNameReplaceDict,
                    rowIDReplaceFunc: id => 5600_00, row =>
                    {
                        var battleGoalBytes = BitConverter.GetBytes(56_0000);

                        for (int i = 0; i < 4; i++)
                        {
                            row.GhettoDataStorage[i + 0x4] = battleGoalBytes[i];
                        }
                    }

                    );

                PortParams("AtkParam_Npc", r => (r >= 2310_00 && r <= 2310_99),
                    byteCountBB: 164, byteCountDS1R: 128,
                    rowNameReplaceDict: attackNameReplaceDict,
                    rowIDReplaceFunc: id => 5600_00 + (id - 2310_00), null
                    );

                PortParams("BehaviorParam", r => r >= 2_23100_000 && r <= 2_23100_999,
                    byteCountBB: 32, byteCountDS1R: 32,
                    rowNameReplaceDict: attackNameReplaceDict,
                    rowIDReplaceFunc: id => 2_56000_000 + (id - 2_23100_000),
                    row =>
                    {
                        var variationIdBytes = BitConverter.GetBytes((row.ID / 1_000) % 1_00000);
                        var behaviorJudgeIdBytes = BitConverter.GetBytes(row.ID % 1_000);
                        int refType = BitConverter.ToInt32(row.GhettoDataStorage, 0xC);

                        if (refType >= 2310_00 && refType <= 2310_99)
                        {
                            refType = 5600_00 + (refType - 2310_00);
                        }

                        var refTypeBytes = BitConverter.GetBytes(refType);
                        for (int i = 0; i < 4; i++)
                        {
                            row.GhettoDataStorage[i] = variationIdBytes[i];
                            row.GhettoDataStorage[i + 0x4] = behaviorJudgeIdBytes[i];
                            row.GhettoDataStorage[i + 0xC] = refTypeBytes[i];
                        }
                    });

                parambndDS1R.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\param\GameParam\GameParam.parambnd.dcx");

                Console.WriteLine("Fatcat");
            }

            ImGui.Separator();

            int NF_GlueDummyPolyToMesh_DummyPolyID = UpdateInt("NF_GlueDummyPolyToMesh_DummyPolyID", "NF_GlueDummyPolyToMesh_DummyPolyID", 200);
            if (DebugTestButton("NF_GlueDummyPolyToMesh"))
            {
                var chrbnd = BND3.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2371.chrbnd.dcx");
                var flverFile = chrbnd.Files.FirstOrDefault(f => f.ID == 200);
                var flver = FLVER2.Read(flverFile.Bytes);



                foreach (var dmy in flver.Dummies)
                {
                    if (dmy.ReferenceID == NF_GlueDummyPolyToMesh_DummyPolyID)
                    {
                        var allBodyVertices = new List<FLVER.Vertex>();
                        foreach (var m in flver.Meshes)
                        {
                            foreach (var v in m.Vertices)
                            {
                                var i1 = v.BoneIndices[0] >= 0 && v.BoneIndices[0] < 255 ? m.BoneIndices[v.BoneIndices[0]] : -1;
                                var i2 = v.BoneIndices[1] >= 0 && v.BoneIndices[1] < 255 ? m.BoneIndices[v.BoneIndices[1]] : -1;
                                var i3 = v.BoneIndices[2] >= 0 && v.BoneIndices[2] < 255 ? m.BoneIndices[v.BoneIndices[2]] : -1;
                                var i4 = v.BoneIndices[3] >= 0 && v.BoneIndices[3] < 255 ? m.BoneIndices[v.BoneIndices[3]] : -1;

                                if (i1 == dmy.AttachBoneIndex || i2 == dmy.AttachBoneIndex || i3 == dmy.AttachBoneIndex || i4 == dmy.AttachBoneIndex)
                                    allBodyVertices.Add(v);
                            }
                            //allBodyVertices.AddRange(m.Vertices);
                        }

                        var closestVertex = allBodyVertices.OrderBy(v => (v.Position - dmy.Position).LengthSquared()).FirstOrDefault();

                        if (closestVertex == null)
                            continue;

                        FLVER2.Mesh meshThatContainsClosestVertex = null;
                        foreach (var m in flver.Meshes)
                        {
                            if (m.Vertices.Contains(closestVertex))
                            {
                                meshThatContainsClosestVertex = m;
                                break;
                            }
                        }

                        int strongestBoneIndex = -1;
                        float strongestBoneWeight = -1;

                        for (int i = 0; i < 4; i++)
                        {
                            if (closestVertex.BoneWeights[i] > strongestBoneWeight)
                            {
                                strongestBoneWeight = closestVertex.BoneWeights[i];
                                strongestBoneIndex = meshThatContainsClosestVertex.BoneIndices[closestVertex.BoneIndices[i]];
                            }
                        }

                        dmy.AttachBoneIndex = (short)strongestBoneIndex;

                        dmy.Position = closestVertex.Position;

                    }
                }

                flverFile.Bytes = flver.Write();
                chrbnd.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2371.chrbnd.dcx");

                Console.WriteLine("fatcat?");
            }

            if (DebugTestButton("NF Arklus DummyPoly Edit"))
            {
                var chrbnd = BND3.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2371.chrbnd.dcx");
                var flverFile = chrbnd.Files.FirstOrDefault(f => f.ID == 200);
                var flver = FLVER2.Read(flverFile.Bytes);

                var allDummyPolyOther = new List<FLVER.Dummy>();
                var allDummyPoly200 = new List<FLVER.Dummy>();

                var newDummyPoly200 = new List<FLVER.Dummy>();
                var newDummyPoly1000 = new List<FLVER.Dummy>();

                foreach (var dmy in flver.Dummies)
                {
                    if (dmy.ReferenceID == 211 || dmy.ReferenceID == 3 || dmy.ReferenceID == 4)
                        continue;

                    if (dmy.ReferenceID == 200)
                        allDummyPoly200.Add(dmy);
                    else
                        allDummyPolyOther.Add(dmy);
                }

                for (int i = 0; i < allDummyPoly200.Count; i++)
                {
                    //if (i == 9 || i == 10 || 
                    //    (i >= 12 && i <= 28) ||
                    //    i == 34 ||
                    //    (i >= 47 && i <= 64) ||
                    //    i == 70 || i == 74 ||  i == 76 ||
                    //    (i >= 78 && i <= 81))
                    if (i == 27)
                    {
                        continue;
                    }
                    //else if (i == 3 || i == 6 || i == 31 || i == 36 || i == 40 || i == 43 || i == 67 || i == 72 || i == 77)
                    //{
                    //    var clone = allDummyPoly200[i].GetClone();
                    //    clone.ReferenceID = 1000;
                    //    newDummyPoly1000.Add(clone);
                    //}
                    else
                    {
                        newDummyPoly200.Add(allDummyPoly200[i]);
                    }




                }

                flver.Dummies.Clear();

                foreach (var d in allDummyPolyOther)
                    flver.Dummies.Add(d);

                foreach (var d in newDummyPoly200)
                    flver.Dummies.Add(d);

                foreach (var d in newDummyPoly1000)
                    flver.Dummies.Add(d);

                flverFile.Bytes = flver.Write();
                chrbnd.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2371.chrbnd.dcx");

                Console.WriteLine("fatcat?");
            }

            ImGui.Separator();

            if (ImGui.TreeNode("DummyPoly Edit List"))
            {
                foreach (var kvp in Scene.MainModel.DummyPolyMan.DummyPolyByRefID)
                {
                    if (ImGui.TreeNode($"DummyPoly[{kvp.Key}]"))
                    {
                        if (!DummyPolySelected.ContainsKey(kvp.Key))
                            DummyPolySelected.Add(kvp.Key, kvp.Value.Select(v => false).ToList());
                        for (int i = 0; i < kvp.Value.Count; i++)
                        {
                            var selected = DummyPolySelected[kvp.Key][i];
                            ImGui.Selectable($"Index {i}", ref selected);
                            DummyPolySelected[kvp.Key][i] = selected;

                            kvp.Value[i].DebugSelected = selected;
                        }

                        ImGui.TreePop();
                    }
                }

                ImGui.TreePop();
            }


            ImGui.Separator();

            string NF_GenerateArklusHoverAnim_AnimName = UpdateString("NF_GenerateArklusHoverAnim_AnimName", "Anim Name", "a10_0000");
            float NF_GenerateArklusHoverAnim_Amplitude = UpdateFloat("NF_GenerateArklusHoverAnim_Amplitude", "Amplitude", 0.25f);
            float NF_GenerateArklusHoverAnim_Duration = UpdateFloat("NF_GenerateArklusHoverAnim_Duration", "Duration", 2);
            string NF_GenerateArklusHoverAnim_TrackName = UpdateString("NF_GenerateArklusHoverAnim_TrackName", "Track Name", "Master");

            if (DebugTestButton("NF_GenerateArklusHoverAnim"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        float time = 0;

                        int hoverTrackIndex = -1;

                        var skeleton = Scene.MainModel.AnimContainer.Skeleton;

                        var baseFrameTransforms = new List<NewBlendableTransform>();
                        for (int t = 0; t < anim.Frames[0].BoneTransforms.Count; t++)
                        {
                            if (anim.TransformTrackNames[t] == NF_GenerateArklusHoverAnim_TrackName)
                            {
                                hoverTrackIndex = t;
                            }

                            var hkxBone = skeleton.HkxSkeleton.FirstOrDefault(b => b.Name == anim.TransformTrackNames[t]);

                            baseFrameTransforms.Add(NewBlendableTransform.Identity);
                        }

                        if (hoverTrackIndex == -1)
                        {

                            return;
                        }

                        anim.Frames.Clear();
                        anim.FrameCount = 0;
                        anim.BlendHint = HKX.AnimationBlendHint.ADDITIVE_DEPRECATED;

                        while (time <= NF_GenerateArklusHoverAnim_Duration + (anim.FrameDuration / 2) /*basically rounding lol*/)
                        {
                            var frame = new SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame();

                            frame.BoneTransforms = baseFrameTransforms.ToList();

                            var ht = frame.BoneTransforms[hoverTrackIndex];
                            ht.Translation.Y = (float)Math.Sin((Math.PI * 2) * (time / NF_GenerateArklusHoverAnim_Duration)) * NF_GenerateArklusHoverAnim_Amplitude;
                            frame.BoneTransforms[hoverTrackIndex] = ht;

                            anim.Frames.Add(frame);

                            anim.FrameCount++;
                            time += anim.FrameDuration;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, NF_GenerateArklusHoverAnim_AnimName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            ImGui.Separator();

            float NF_ScaleAnimation_Scale = UpdateFloat("NF_ScaleAnimation_Scale", "Animation Scale", 1);

            if (DebugTestButton("NF_ScaleAnimation"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        foreach (var f in anim.Frames)
                        {
                            //for (int t = 0; t < f.BoneTransforms.Count; t++)
                            //{
                            //    var tr = f.BoneTransforms[t];
                            //    tr.Translation *= NF_ScaleAnimation_Scale;
                            //    f.BoneTransforms[t] = tr;
                            //}

                            //f.RootMotionTranslation *= NF_ScaleAnimation_Scale;
                            f.RootMotionRotation /= NF_ScaleAnimation_Scale;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, mainScreen.GetAnimListInfoOfAnim(mainScreen.SelectedTaeAnim)?.GetName() ?? Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            ImGui.Separator();
            ImGui.Separator();

            if (DebugTestButton("NF_AdjustDodges"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                    },
                    (fixer, anim) =>
                    {
                        var dashDelta = anim.Frames[5].RootMotionTranslation - anim.Frames[4].RootMotionTranslation;

                        List<NVector3> rootMotionDeltas = new List<NVector3>();
                        for (int i = 0; i < anim.Frames.Count; i++)
                        {
                            if (i == 0)
                                rootMotionDeltas.Add(NVector3.Zero);
                            else
                                rootMotionDeltas.Add(anim.Frames[i].RootMotionTranslation - anim.Frames[i - 1].RootMotionTranslation);
                        }

                        anim.Frames[5].RootMotionTranslation = anim.Frames[4].RootMotionTranslation + (dashDelta * 0.4f);

                        NVector3 curPos = anim.Frames[5].RootMotionTranslation;

                        for (int f = 6; f < anim.Frames.Count; f++)
                        {
                            curPos += rootMotionDeltas[f];
                            anim.Frames[f].RootMotionTranslation = curPos;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, mainScreen.GetAnimListInfoOfAnim(mainScreen.SelectedTaeAnim)?.GetName() ?? Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            ImGui.Separator();

            int NF_RemapIdleMemes_IdleAnimID = UpdateInt("NF_RemapIdleMemes_IdleAnimID", "NF_RemapIdleMemes_IdleAnimID");

            if (DebugTestButton("NF_RemapIdleMemes"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var skeleton = Scene.MainModel.AnimContainer.Skeleton;

                HavokSkeletonRemapper.IdleCorrectEnvelope RightLegACorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(13, 20, 49, 55, (1, 0));
                HavokSkeletonRemapper.IdleCorrectEnvelope LeftLegACorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 4, 60, 65, (1, 0));
                HavokSkeletonRemapper.IdleCorrectEnvelope RightLegBCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 17, 26, 31, (1, 0));
                HavokSkeletonRemapper.IdleCorrectEnvelope LeftLegBCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 17, 44, 52, (1, 0));
                HavokSkeletonRemapper.IdleCorrectEnvelope CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 18, 40, 55, (1, 0));

                string BoneName_RightLegA = "RLeg_a_Collarbone";
                string BoneName_RightLegB = "RLeg_b_1";
                string BoneName_LeftLegA = "LLeg_a_Collarbone";
                string BoneName_LeftLegB = "LLeg_b_1";



                Dictionary<int, int> idleAnimTrackIndicesByBone = new Dictionary<int, int>();

                List<SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame> idleAnimFrames = new List<SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame>();

                var idleAnimNameString = GameRoot.SplitAnimID.FromFullID(NF_RemapIdleMemes_IdleAnimID).GetFormattedIDString() + ".hkx";

                var idleAnim = Scene.MainModel.AnimContainer.FindAnimation(idleAnimNameString);

                Dictionary<string, NewBlendableTransform> compareDeltaFrame_Bones_Idle_FK = new Dictionary<string, NewBlendableTransform>();

                var idleAnimTest = splineFixer.ProcessAnimation(idleAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                        int boneCount = idleAnim.data.HkxBoneIndexToTransformTrackMap.Length;
                        var boneNameMap = idleAnim.data.GetTransformTrackBoneNameMapping();
                        foreach (var kvp in boneNameMap)
                        {
                            var fkOfBone = fixer.GetTargetFKTransform(0, idleAnim.data.TransformTrackIndexToHkxBoneMap[kvp.Key]);
                            compareDeltaFrame_Bones_Idle_FK.Add(kvp.Value, fkOfBone);
                        }
                    },
                    (fixer, anim) =>
                    {
                        int i = 0;
                        foreach (var trackName in anim.TransformTrackNames)
                        {
                            idleAnimTrackIndicesByBone.Add(anim.TransformTrackToBoneIndices[trackName], i++);
                        }

                        foreach (var f in anim.Frames)
                            idleAnimFrames.Add(f);
                    })

                }); ;

                var curAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                var fixedAnim = splineFixer.ProcessAnimation(curAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {
                        //Dictionary<string, NewBlendableTransform> compareDeltaFrame_Bones_Base_FK = new Dictionary<string, NewBlendableTransform>();

                        //int boneCount = curAnim.data.HkxBoneIndexToTransformTrackMap.Length;
                        //var boneNameMap = curAnim.data.GetTransformTrackBoneNameMapping();
                        //foreach (var kvp in boneNameMap)
                        //{
                        //    var fkOfBone = fixer.GetTargetFKTransform(0, curAnim.data.TransformTrackIndexToHkxBoneMap[kvp.Key]);
                        //    compareDeltaFrame_Bones_Base_FK.Add(kvp.Value, fkOfBone);
                        //}

                        //for (int f = 0; f < curAnim.FrameCount; f++)
                        //{
                        //    //for (int i = 0; i < boneCount; i++)
                        //    //{
                        //    //    var fkOfBone = fixer.GetTargetFKTransform(f, i);
                        //    //    fkOfBone *= (compareDeltaFrame_Bones_Idle_FK[i] * NewBlendableTransform.Invert(compareDeltaFrame_Bones_Base_FK[i]));
                        //    //    fixer.SetTargetFKTransform(f, i, fkOfBone);
                        //    //}

                        //    foreach (var kvp in boneNameMap)
                        //    {
                        //        var trackName = kvp.Value;
                        //        var fkOfBone = fixer.GetTargetFKTransform(f, curAnim.data.TransformTrackIndexToHkxBoneMap[kvp.Key]);
                        //        fkOfBone = (compareDeltaFrame_Bones_Idle_FK[trackName] * NewBlendableTransform.Invert(compareDeltaFrame_Bones_Base_FK[trackName])) * fkOfBone;

                        //        //fkOfBone = compareDeltaFrame_Bones_Base_FK[trackName];

                        //        fixer.SetTargetFKTransform(f, curAnim.data.TransformTrackIndexToHkxBoneMap[kvp.Key], fkOfBone);
                        //    }
                        //}
                    },
                    (fixer, anim) =>
                    {

                        var compareDeltaFrame_Idle = idleAnimFrames[0].BoneTransforms;
                        List<NewBlendableTransform> compareDeltaFrame_Base = anim.Frames[0].BoneTransforms.ToList();

                        for (int t = 0; t < compareDeltaFrame_Base.Count; t++)
                            {
                                var trackName = anim.TransformTrackNames[t];
                                var idleTrackIndex = idleAnimTrackIndicesByBone[anim.TransformTrackToBoneIndices[trackName]];
                                var tr = compareDeltaFrame_Base[t];
                                //tr *= (compareDeltaFrame_Idle[t] * NewBlendableTransform.Invert(compareDeltaFrame_Base[idleTrackIndex]));
                                tr.Translation = compareDeltaFrame_Idle[t].Translation;
                                compareDeltaFrame_Base[t] = tr;
                            }

                        for (int f = 0; f < anim.Frames.Count; f++)
                        {
                            for (int t = 0; t < anim.Frames[f].BoneTransforms.Count; t++)
                            {
                                var trackName = anim.TransformTrackNames[t];

                                var ancestors = skeleton.GetAncestorsBoneDescendsFrom(skeleton.HkxSkeleton.First(b => b.Name == trackName),
                                    BoneName_RightLegA, BoneName_RightLegB, BoneName_LeftLegA, BoneName_LeftLegB);

                                var correct = CoreCorrect;

                                if (ancestors.Contains(BoneName_RightLegA))
                                    correct = RightLegACorrect;
                                else if (ancestors.Contains(BoneName_RightLegB))
                                    correct = RightLegBCorrect;
                                else if (ancestors.Contains(BoneName_LeftLegA))
                                    correct = LeftLegACorrect;
                                else if (ancestors.Contains(BoneName_LeftLegB))
                                    correct = LeftLegBCorrect;

                                var idleTrackIndex = idleAnimTrackIndicesByBone[anim.TransformTrackToBoneIndices[trackName]];
                                var tr = anim.Frames[f].BoneTransforms[t];

                                var correctedTR = (compareDeltaFrame_Idle[idleTrackIndex] * NewBlendableTransform.Invert(compareDeltaFrame_Base[t])) * tr;

                                var correctBlend = correct.GetIdleBlendSine(f, anim.Frames.Count);

                                tr = NewBlendableTransform.Lerp(tr, correctedTR, correctBlend);

                                tr.Translation = compareDeltaFrame_Idle[t].Translation;
                                anim.Frames[f].BoneTransforms[t] = tr;
                            }
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, mainScreen.GetAnimListInfoOfAnim(mainScreen.SelectedTaeAnim)?.GetName() ?? Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            ImGui.Separator();

            float JumpHeightMultiplier_Multiplier = UpdateFloat("JumpHeightMultiplier_Multiplier", "Jump Height Multiplier", 1.0f);
            if (DebugTestButton("[JumpHeightMultiplier]"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var fixedAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        List<NVector3> rootMotionDeltas = new List<NVector3>();
                        var masterIndex = anim.TransformTrackNames.FindIndex(m => m.ToUpper().Trim() == "MASTER");

                        var baseMasterY = anim.Frames[0].BoneTransforms[masterIndex].Translation.Y;

                        for (int f = 0; f < anim.Frames.Count; f++)
                        {
                            if (f > 0)
                                rootMotionDeltas.Add(anim.Frames[f].RootMotionTranslation - anim.Frames[f - 1].RootMotionTranslation);

                            var masterTransform = anim.Frames[f].BoneTransforms[masterIndex];
                            var y = masterTransform.Translation.Y;
                            if (y > baseMasterY)
                            {
                                float distanceAboveBase = y - baseMasterY;
                                distanceAboveBase *= JumpHeightMultiplier_Multiplier;
                                y = baseMasterY + distanceAboveBase;
                                masterTransform.Translation.Y = y;
                            }

                            //masterTransform.Translation.Y *= 3;
                            anim.Frames[f].BoneTransforms[masterIndex] = masterTransform;
                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, mainScreen.GetAnimListInfoOfAnim(mainScreen.SelectedTaeAnim)?.GetName() ?? Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }



            ImGui.Separator();



            int NF_CombineIdleWithAdditiveAnim_AdditiveAnimID = UpdateInt("NF_CombineIdleWithAdditiveAnim_AdditiveAnimID", "Additive Anim ID");
            float NF_CombineIdleWithAdditiveAnim_AdditiveAnimWeight = UpdateFloat("NF_CombineIdleWithAdditiveAnim_AdditiveAnimWeight", "Additive Anim Weight");

            if (DebugTestButton("[NF_CombineIdleWithAdditiveAnim]"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                Dictionary<int, int> additiveAnimTrackIndicesByBone = new Dictionary<int, int>();

                List<SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame> additiveAnimFrames = new List<SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame>();
                var additiveAnim = Scene.MainModel.AnimContainer.FindAnimation(
                    GameRoot.SplitAnimID.FromFullID(NF_CombineIdleWithAdditiveAnim_AdditiveAnimID).GetFormattedIDString() + ".hkx");

                var additiveAnimTest = splineFixer.ProcessAnimation(additiveAnim, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        int i = 0;
                        foreach (var trackName in anim.TransformTrackNames)
                        {
                            additiveAnimTrackIndicesByBone.Add(anim.TransformTrackToBoneIndices[trackName], i++);
                        }

                        foreach (var f in anim.Frames)
                            additiveAnimFrames.Add(f);
                    })

                }); ;

                var fixedAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        var baseAnim = Scene.MainModel.AnimContainer.CurrentAnimation;
                        int baseStartFrame = (baseAnim.FrameCount - 1) - (additiveAnim.FrameCount);

                        while (baseStartFrame < 0)
                            baseStartFrame += baseAnim.FrameCount;

                        baseAnim.CurrentFrame = baseStartFrame;
                        baseAnim.SyncRootMotion(NVector4.Zero);


                        baseAnim.EnableLooping = true;
                        var newFrames = new List<SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame>();
                        for (int f = 0; f < additiveAnimFrames.Count; f++)
                        {
                            var nf = new SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame();
                            for (int t = 0; t < anim.Frames[0].BoneTransforms.Count; t++)
                            {
                                var boneIndex = anim.TransformTrackToBoneIndices[anim.TransformTrackNames[t]];
                                var additiveTrans = NewBlendableTransform.Lerp(NewBlendableTransform.Identity, additiveAnimFrames[f].BoneTransforms[additiveAnimTrackIndicesByBone[boneIndex]], NF_CombineIdleWithAdditiveAnim_AdditiveAnimWeight);
                                var baseTrans = baseAnim.GetBlendableTransformOnCurrentFrame(boneIndex);
                                //nf.BoneTransforms.Add(baseTrans * additiveTrans);
                                nf.BoneTransforms.Add(new NewBlendableTransform((baseTrans.GetMatrixScale() * baseTrans.GetMatrix()) * (additiveTrans.GetMatrixScale() * additiveTrans.GetMatrix())));
                            }
                            nf.RootMotionTranslation = baseAnim.RootMotion.CurrentTransform.XYZ();
                            nf.RootMotionRotation = baseAnim.RootMotion.CurrentTransform.W;
                            newFrames.Add(nf);

                            baseAnim.ScrubRelative(baseAnim.FrameDuration);
                        }

                        anim.Duration = (newFrames.Count - 1) * baseAnim.FrameDuration;
                        anim.FrameCount = newFrames.Count;
                        anim.Frames = newFrames;
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, mainScreen.GetAnimListInfoOfAnim(mainScreen.SelectedTaeAnim)?.GetName() ?? Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            ImGui.Separator();

            if (DebugTestButton("Copy Nightfall Backups"))
            {
                var backupsFolder = @"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr";
                List<string> backupsCopied = new List<string>();
                foreach (var f in Directory.GetFiles(backupsFolder, "*.dsasautobak*"))
                {
                    var destFileName = @"E:\DarkSoulsModding_Nightfall\_DSAS_Backups\" + Path.GetFileName(f);
                    if (!File.Exists(destFileName))
                    {
                        backupsCopied.Add(destFileName);
                        File.Copy(f, destFileName);
                    }
                }
                if (backupsCopied.Count > 0)
                {
                    DialogManager.DialogOK("Backup Copy Result", $"New backups copied:\n    {string.Join("\n    ", backupsCopied)}");
                }
                else
                {
                    DialogManager.DialogOK("Backup Copy Result", "All backups already copied. No new files copied.");
                }
            }

            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();

            if (DebugTestButton("QuickTest[See Code]"))
            {
                var flv = FLVER2.Read(@"E:\Program Files (x86)\Steam\steamapps\common\Dark Souls Prepare to Die Edition\DATA\map\m15_01_00_00\m1000B1A15.flver");

                Console.WriteLine("fatcat");
            }

            ImGui.Separator();

            if (DebugTestButton("NF Player Jump On Mount Vertical motion and root motion fix"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var fixedAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        List<NVector3> rootMotionDeltas = new List<NVector3>();
                        var masterIndex = anim.TransformTrackNames.FindIndex(m => m.ToUpper().Trim() == "MASTER");

                        var baseMasterY = anim.Frames[0].BoneTransforms[masterIndex].Translation.Y;

                        for (int f = 0; f < anim.Frames.Count; f++)
                        {
                            if (f > 0)
                                rootMotionDeltas.Add(anim.Frames[f].RootMotionTranslation - anim.Frames[f - 1].RootMotionTranslation);

                            var masterTransform = anim.Frames[f].BoneTransforms[masterIndex];
                            var y = masterTransform.Translation.Y;
                            if (y > baseMasterY)
                            {
                                float distanceAboveBase = y - baseMasterY;
                                distanceAboveBase *= 3;
                                y = baseMasterY + distanceAboveBase;
                                masterTransform.Translation.Y = y;
                            }

                            //masterTransform.Translation.Y *= 3;
                            anim.Frames[f].BoneTransforms[masterIndex] = masterTransform;
                        }

                        NVector3 currentRootMotion = anim.Frames[0].RootMotionTranslation;
                        for (int i = 0; i < rootMotionDeltas.Count; i++)
                        {
                            float rootMotionMeme = MathHelper.Clamp((float)i / 15f, 0, 1);
                            currentRootMotion += NVector3.Lerp(rootMotionDeltas[i], NVector3.Zero, rootMotionMeme);

                            anim.Frames[i].RootMotionTranslation = currentRootMotion;

                        }
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            if (DebugTestButton("NF Arklus TurnAnim Fix"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var fixedAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        const int frameCount = 30;
                        float desiredRotation = (SoulsAssetPipeline.SapMath.Pi);


                        var finalFrame = anim.Frames[frameCount - 1];
                        float multNeededForDesiredRotation = desiredRotation / finalFrame.RootMotionRotation;
                        var newFrames = new List<SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame>();
                        for (int i = 0; i < frameCount; i++)
                        {
                            var f = anim.Frames[i];
                            var motionFrameSample = anim.GetSampledFrame(((float)i / (float)(frameCount - 1)) * (anim.Frames.Count - 1));
                            f.RootMotionRotation *= multNeededForDesiredRotation;
                            for (int t = 0; t < f.BoneTransforms.Count; t++)
                            {
                                f.BoneTransforms[t] = motionFrameSample.BoneTransforms[t];
                            }
                            newFrames.Add(f);
                        }

                        //var newLastFrame = new SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame();
                        //newLastFrame.BoneTransforms = newFrames[0].BoneTransforms;
                        //newLastFrame.RootMotionTranslation = newFrames[newFrames.Count - 1].RootMotionTranslation;
                        //newLastFrame.RootMotionRotation = newFrames[newFrames.Count - 1].RootMotionRotation;

                        //newFrames.Add(newLastFrame);

                        anim.Frames = newFrames;
                    })

                }); ;

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName,
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();
            }

            ImGui.Separator();

            string CreateNFEnemyAimAttacks_AimBoneName1 = UpdateString("CreateNFEnemyAimAttacks_AimBoneName1", "Aim Bone 1 Name");
            float CreateNFEnemyAimAttacks_AimBone1Ratio = UpdateFloat("CreateNFEnemyAimAttacks_AimBone1Ratio", "Aim Bone 1 Ratio", 1);

            string CreateNFEnemyAimAttacks_AimBoneName2 = UpdateString("CreateNFEnemyAimAttacks_AimBoneName2", "Aim Bone 2 Name", "");
            float CreateNFEnemyAimAttacks_AimBone2Ratio = UpdateFloat("CreateNFEnemyAimAttacks_AimBone2Ratio", "Aim Bone 2 Ratio", 0.5f);

            string CreateNFEnemyAimAttacks_AimBoneName3 = UpdateString("CreateNFEnemyAimAttacks_AimBoneName3", "Aim Bone 3 Name", "");
            float CreateNFEnemyAimAttacks_AimBone3Ratio = UpdateFloat("CreateNFEnemyAimAttacks_AimBone3Ratio", "Aim Bone 3 Ratio", 0.25f);

            int CreateNFEnemyAimAttacks_AimUpAnimID = UpdateInt("CreateNFEnemyAimAttacks_AimUpAnimID", "Aim Up Anim ID");
            int CreateNFEnemyAimAttacks_AimDownAnimID = UpdateInt("CreateNFEnemyAimAttacks_AimDownAnimID", "AimDownAnimID");



            if (DebugTestButton("[CreateNFEnemyAimAttacks]"))
            {
                Console.Write("fatcat");

                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                void DoEnemyAimThing(HavokSplineFixer fixer, SoulsAssetPipeline.AnimationImporting.ImportedAnimation anim, float aimAngle)
                {

                    float totalBoneRotateRatio = CreateNFEnemyAimAttacks_AimBone1Ratio;

                    if (!string.IsNullOrWhiteSpace(CreateNFEnemyAimAttacks_AimBoneName2))
                        totalBoneRotateRatio += CreateNFEnemyAimAttacks_AimBone2Ratio;
                    if (!string.IsNullOrWhiteSpace(CreateNFEnemyAimAttacks_AimBoneName3))
                        totalBoneRotateRatio += CreateNFEnemyAimAttacks_AimBone3Ratio;

                    float boneRotMult1 = CreateNFEnemyAimAttacks_AimBone1Ratio / totalBoneRotateRatio;
                    float boneRotMult2 = CreateNFEnemyAimAttacks_AimBone2Ratio / totalBoneRotateRatio;
                    float boneRotMult3 = CreateNFEnemyAimAttacks_AimBone3Ratio / totalBoneRotateRatio;

                    int boneIndex1 = anim.TransformTrackNames.IndexOf(CreateNFEnemyAimAttacks_AimBoneName1);
                    int boneIndex2 = anim.TransformTrackNames.IndexOf(CreateNFEnemyAimAttacks_AimBoneName2);
                    int boneIndex3 = anim.TransformTrackNames.IndexOf(CreateNFEnemyAimAttacks_AimBoneName3);

                    var firstFrame = anim.Frames[0];
                    for (int i = 0; i < firstFrame.BoneTransforms.Count; i++)
                        firstFrame.BoneTransforms[i] = NewBlendableTransform.Identity;

                    firstFrame.RootMotionTranslation = NVector3.Zero;
                    firstFrame.RootMotionRotation = 0;

                    if (boneIndex1 >= 0)
                        firstFrame.BoneTransforms[boneIndex1] = new NewBlendableTransform(NMatrix.CreateRotationY(aimAngle * boneRotMult1));

                    if (boneIndex2 >= 0)
                        firstFrame.BoneTransforms[boneIndex2] = new NewBlendableTransform(NMatrix.CreateRotationY(aimAngle * boneRotMult2));

                    if (boneIndex3 >= 0)
                        firstFrame.BoneTransforms[boneIndex3] = new NewBlendableTransform(NMatrix.CreateRotationY(aimAngle * boneRotMult3));

                    anim.Frames.Clear();
                    anim.FrameCount = 10;
                    anim.Duration = 11 * anim.FrameDuration;
                    anim.BlendHint = HKX.AnimationBlendHint.ADDITIVE;
                    for (int i = 0; i < 10; i++)
                        anim.Frames.Add(firstFrame);
                }

                var aimUpAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        DoEnemyAimThing(fixer, anim, MathHelper.PiOver2);
                    })
                });

                var aimDownAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GenericSplineFixEntry(fixer =>
                    {

                    },
                    (fixer, anim) =>
                    {
                        DoEnemyAimThing(fixer, anim, -MathHelper.PiOver2);
                    })
                });

                importRemappedAnimLol(aimUpAnim, GameRoot.SplitAnimID.FromFullID(CreateNFEnemyAimAttacks_AimUpAnimID).GetFormattedIDString() + ".hkx",
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Up");
                importRemappedAnimLol(aimDownAnim, GameRoot.SplitAnimID.FromFullID(CreateNFEnemyAimAttacks_AimDownAnimID).GetFormattedIDString() + ".hkx",
                    noTaeEntry: true, mainScreen.Graph.AnimRef, $"{mainScreen.Graph.AnimRef.AnimFileName} - Aim Down");

                mainScreen.RecreateAnimList();

                Console.Write("fatcat");
            }

            ImGui.Separator();

            int RemapChrSoundIDs_CurChr = UpdateInt("RemapChrSoundIDs_CurChr", "Current ChrID");
            int RemapChrSoundIDs_NewChr = UpdateInt("RemapChrSoundIDs_NewChr", "New ChrID");


            if (DebugTestButton("[Remap Chr Sound IDs]"))
            {
                Console.Write("fatcat");

                foreach (var t in mainScreen.FileContainer.AllTAE)
                {
                    foreach (var a in t.Animations)
                    {
                        foreach (var e in a.Events)
                        {
                            if (e.TypeName?.StartsWith("PlaySound") ?? false)
                            {
                                var soundID = Convert.ToInt32(e.Parameters["SoundID"]);

                                int curChrIDStart = (RemapChrSoundIDs_CurChr * 1_00000);
                                if (soundID >= curChrIDStart && soundID < curChrIDStart + 1_00000)
                                {
                                    int subID = soundID % 1_00000;
                                    e.Parameters["SoundID"] = (RemapChrSoundIDs_NewChr * 1_00000) + subID;
                                    a.SetIsModified(true);
                                    t.SetIsModified(true);
                                }
                            }
                        }
                    }
                }

                Console.Write("fatcat");
            }

            ImGui.Separator();

            if (DebugTestButton("REMOVE ALL FOOTSTEP SOUNDS ON CHARACTER"))
            {
                Console.Write("fatcat");

                foreach (var t in mainScreen.FileContainer.AllTAE)
                {
                    foreach (var a in t.Animations)
                    {
                        var eventsToDelete = new List<TAE.Event>();
                        foreach (var e in a.Events)
                        {
                            if (e.TypeName?.StartsWith("PlaySound") ?? false)
                            {
                                var soundType = Convert.ToInt32(e.Parameters["SoundType"]);
                                if (soundType == 8)
                                {
                                    eventsToDelete.Add(e);
                                }
                            }
                        }
                        if (eventsToDelete.Count > 0)
                        {
                            a.SetIsModified(true);
                            t.SetIsModified(true);
                            foreach (var evr in eventsToDelete)
                                a.Events.Remove(evr);
                        }
                    }
                }

                Console.Write("fatcat");
            }


            if (DebugTestButton("Scan TAE in PTDE"))
            {
                List<string> event305s = new List<string>();
                List<string> event306s = new List<string>();
                var ptdeAnibnds = Directory.GetFiles(@"E:\Program Files (x86)\Steam\steamapps\common\Dark Souls Prepare to Die Edition\DATA\chr", "*.anibnd");
                foreach (var a in ptdeAnibnds)
                {
                    var bnd = BND3.Read(a);
                    var taeFile = bnd.Files.FirstOrDefault(b => b.Name.ToLower().EndsWith(".tae"));
                    if (taeFile != null)
                    {
                        var taeShortName = Utils.GetShortIngameFileName(taeFile.Name);
                        var tae = TAE.Read(taeFile.Bytes);
                        foreach (var ta in tae.Animations)
                        {
                            foreach (var ev in ta.Events)
                            {
                                if (ev.Type == 305)
                                {
                                    event305s.Add($"Tae{taeShortName} - Anim{ta.ID} - Event305({getByteString(ev.GetParameterBytes(GameRoot.IsBigEndianGame))})");
                                }
                                else if (ev.Type == 306)
                                {
                                    event306s.Add($"Tae{taeShortName} - Anim{ta.ID} - Event306({getByteString(ev.GetParameterBytes(GameRoot.IsBigEndianGame))})");
                                }
                            }
                        }
                    }
                }

                event305s = event305s.OrderBy(x => x).ToList();
                event306s = event306s.OrderBy(x => x).ToList();

                var sb = new StringBuilder();

                foreach (var ev in event305s)
                {
                    sb.AppendLine(ev);
                }
                foreach (var ev in event306s)
                {
                    sb.AppendLine(ev);
                }
                System.Windows.Forms.Clipboard.SetText(sb.ToString(), System.Windows.Forms.TextDataFormat.UnicodeText);
                Console.WriteLine("fatcat");
            }

            NewAnimSkeleton_HKX LoadSkel(string skelPath)
            {
                var bbSkelHkx = HKX.Read(skelPath);
                //HKX.HKASkeleton hk_skeleton_bb = null;
                //foreach (var o in bbSkelHkx.DataSection.Objects)
                //{
                //    if (o is HKX.HKASkeleton asSkeleton)
                //        hk_skeleton_bb = asSkeleton;
                //}
                var skel = new NewAnimSkeleton_HKX();
                //skel.SkeletonPackfile = bbSkelHkx;
                skel.LoadHKXSkeleton(bbSkelHkx);
                return skel;
            }

            void importRemappedAnimLol(SoulsAssetPipeline.AnimationImporting.ImportedAnimation importedAnim, string ds1AnimName, bool noTaeEntry = true, TAE.Animation animToGetEventsFrom = null, string newTaeEntryName = null)
            {
                try
                {

                    var readyForGame = ImportedAnimationConverter.GetAnimReadyToPutIntoGameFromImported(importedAnim);



                    if (ds1AnimName.ToLower().EndsWith(".hkx"))
                        ds1AnimName = ds1AnimName.Substring(0, ds1AnimName.Length - 4);

                    if (int.TryParse(ds1AnimName.Replace("a", "").Replace("_", ""), out int id))
                    {
                        var shortName = ds1AnimName;

                        var splitID = GameRoot.SplitAnimID.FromFullID(id);

                        if (GameRoot.CurrentAnimIDFormatType == GameRoot.AnimIDFormattingType.aXX_YYYY)
                        {
                            shortName = $"a{splitID.TaeID:D2}_{splitID.SubID:D4}";
                        }
                        else if (GameRoot.CurrentAnimIDFormatType == GameRoot.AnimIDFormattingType.aXXX_YYYYYY)
                        {
                            shortName = $"a{splitID.TaeID:D3}_{splitID.SubID:D6}";
                        }
                        else if (GameRoot.CurrentAnimIDFormatType == GameRoot.AnimIDFormattingType.aXX_YY_ZZZZ)
                        {
                            shortName = $"a{splitID.TaeID:D3}_{splitID.SubID:D6}";
                            shortName.Insert(6, "_");
                        }
                        else
                        {
                            throw new NotImplementedException();
                        }

                        mainScreen.FileContainer.AddNewHKX(shortName, readyForGame.DataForGame, out byte[] dataForAnimContainer);//, readyForGame.DataForGame);

                        if (readyForGame.DataForGame == null)
                        {
                            DialogManager.DialogOK("Failed", "Failed to save (TagTools refused to work), just try again.");
                            return;
                        }

                        mainScreen.Graph.ViewportInteractor.CurrentModel.AnimContainer.AddNewHKXToLoad(shortName + ".hkx", readyForGame.DataForGame);
                        mainScreen.ReselectCurrentAnimation();
                        mainScreen.HardReset();

                        if (!noTaeEntry)
                        {

                            var anim = mainScreen.CreateNewAnimWithFullID(id, animToGetEventsFrom?.AnimFileName ?? ds1AnimName, nukeExisting: true);

                            anim.SetIsModified(true);

                            if (animToGetEventsFrom != null)
                            {
                                foreach (var ev in animToGetEventsFrom.Events)
                                {
                                    if (templateDS1[0].ContainsKey(ev.Type))
                                    {
                                        if (ev.Type == 0)
                                        {
                                            var jumpTableID = Convert.ToInt32(ev.Parameters["JumpTableID"]);
                                            if (!templateDS1[0][0]["JumpTableID"].EnumEntries.ContainsValue(jumpTableID))
                                            {
                                                continue;
                                            }
                                        }
                                        var cloneEv = ev.GetClone(GameRoot.IsBigEndianGame);
                                        cloneEv.Group = null;
                                        cloneEv.ApplyTemplate(GameRoot.IsBigEndianGame, templateDS1[0][cloneEv.Type]);
                                        anim.Events.Add(cloneEv);
                                    }
                                }
                            }
                        }

                        //DialogManager.DialogOK("Import Complete", $"Finished importing animation HKX and TAE.");
                    }
                }
                catch (Exception ex)
                {
                    DialogManager.DialogOK("Import Failed", $"Animation invalid. Unable to convert from XML to HKX. Make sure there are no NaN values in transforms.\n\n{ex.Message}");
                }
            }

            void askToImportAnim(SoulsAssetPipeline.AnimationImporting.ImportedAnimation anim, bool noTaeEntry = true, TAE.Animation animToGetEventsFrom = null, string newTaeEntryName = null)
            {
                DialogManager.AskForInputString("Save To Animation ID", "Enter the animation ID to save to.\n" +
                "Accepts the full string with prefix or just the ID as a number.",
                GameRoot.CurrentAnimIDFormatType.ToString(), result =>
                {
                    Main.WinForm.Invoke(new Action(() =>
                    {
                        if (int.TryParse(result.Replace("a", "").Replace("_", ""), out int id))
                        {
                            var splitIdStr = GameRoot.SplitAnimID.FromFullID(id).GetFormattedIDString();
                            importRemappedAnimLol(anim, splitIdStr, noTaeEntry, animToGetEventsFrom, newTaeEntryName);
                        }
                        else
                        {
                            DialogManager.DialogOK("Failed", $"\"{result}\" is not a valid animation ID.");
                        }
                    }));
                }, canBeCancelled: true);
            }

            //if (DebugTestButton("spline anim experiemnts"))
            //{
            //    NewHavokAnimation LoadAnimFatcat(string ds3AnimName, HKX.HKXVariation hkxVariation, NewAnimSkeleton_HKX skel = null)
            //    {
            //        var ds3animHkx = HKX.Read(ds3AnimName, hkxVariation, false);

            //        HKX.HKAAnimationBinding hk_binding = null;
            //        HKX.HKASplineCompressedAnimation hk_anim = null;

            //        HKX.HKADefaultAnimatedReferenceFrame hk_RefFrame = null;

            //        foreach (var o in ds3animHkx.DataSection.Objects)
            //        {
            //            if (o is HKX.HKAAnimationBinding asBinding)
            //                hk_binding = asBinding;
            //            else if (o is HKX.HKASplineCompressedAnimation asAnim)
            //                hk_anim = asAnim;
            //            else if (o is HKX.HKADefaultAnimatedReferenceFrame asRefFrame)
            //                hk_RefFrame = asRefFrame;
            //        }

            //        var ds3Anim = new NewHavokAnimation_SplineCompressed("TestDS3Anim", skel, hk_RefFrame, hk_binding, hk_anim, null);
            //        return ds3Anim;
            //    }

            //    var skell = LoadSkel(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5350-anibnd-dcx-2010\Model\chr\c5350\hkxx64\Skeleton.HKX");
            //    var anim = LoadAnimFatcat(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c5350-anibnd-dcx-2010\Model\chr\c5350\hkxx64\a00_3006.hkx", HKX.HKXVariation.HKXDS1, skell);

            //    var splineFixer = new HavokSplineFixer(skell);


            //}

            //ImGui.InputText("Bone Name[0]:", ref SplineFixCfg_BoneName, 64);
            //ImGui.InputText("CounterRot Bone Name[0]:", ref SplineFixCfg_CounterBoneName, 64);
            //ImGui.InputInt("Start Frame[0]:", ref SplineFixCfg_StartFrame);
            //ImGui.InputInt("End Frame[0]:", ref SplineFixCfg_EndFrame);

            //ImGui.InputText("Bone Name[1]:", ref SplineFixCfg_BoneName2, 64);
            //ImGui.InputText("CounterRot Bone Name[1]:", ref SplineFixCfg_CounterBoneName2, 64);
            //ImGui.InputInt("Start Frame[1]:", ref SplineFixCfg_StartFrame2);
            //ImGui.InputInt("End Frame[1]:", ref SplineFixCfg_EndFrame2);

            //if (DebugTestButton("TEST: Attempt to fix current animation spline compression."))
            //{
            //    var skell = Scene.MainModel.AnimContainer.Skeleton;
            //    var anim = Scene.MainModel.AnimContainer.CurrentAnimation;

            //    var splineFixer = new HavokSplineFixer(skell);

            //    var fixedAnim = splineFixer.ProcessAnimation(anim, new List<HavokSplineFixer.SplineFixEntry>
            //    {
            //        new HavokSplineFixer.SplineFixEntry(SplineFixCfg_BoneName, SplineFixCfg_CounterBoneName, SplineFixCfg_StartFrame, SplineFixCfg_EndFrame),
            //        new HavokSplineFixer.SplineFixEntry(SplineFixCfg_BoneName2, SplineFixCfg_CounterBoneName2, SplineFixCfg_StartFrame2, SplineFixCfg_EndFrame2),
            //    });

            //    importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName);

            //    //Console.WriteLine("fatcat");
            //}

            //if (DebugTestButton("ROOT MOTION EXTRACT"))
            //{
            //    var skell = Scene.MainModel.AnimContainer.Skeleton;
            //    var anim = Scene.MainModel.AnimContainer.CurrentAnimation;

            //    var splineFixer = new HavokRootMotionExtractor(skell);

            //    var fixedAnim = splineFixer.ProcessAnimation(anim, new HavokRootMotionExtractor.RootMotionExtractorConfig()
            //    {
            //        FootPlants = new List<HavokRootMotionExtractor.FootPlantedTimeframe>
            //        {
            //            new HavokRootMotionExtractor.FootPlantedTimeframe(HavokRootMotionExtractor.FootType.Right, 0, 18),
            //            new HavokRootMotionExtractor.FootPlantedTimeframe(HavokRootMotionExtractor.FootType.Left, 26, 62),
            //        },
            //    });

            //    importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName);

            //    //Console.WriteLine("fatcat");
            //}



            if (DebugTestButton("NF ARKLUS"))
            {
                Console.Write("fatcat");

                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var fixedAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.NF_ArklusFix()
                });

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName, noTaeEntry: true);

                Console.Write("fatcat");
            }

            if (DebugTestButton("Try to fix garg anims"))
            {
                var splineFixer = new HavokSplineFixer(Scene.MainModel.AnimContainer.Skeleton);

                var fixedAnim = splineFixer.ProcessAnimation(Scene.MainModel.AnimContainer.CurrentAnimation, new List<HavokSplineFixer.SplineFixEntry>()
                {
                    new HavokSplineFixer.SplineFixEntry.GimbalFlip(11, 21, "RArm22", "RArmPalm"),
                });

                importRemappedAnimLol(fixedAnim, Scene.MainModel.AnimContainer.CurrentAnimationName, noTaeEntry: true);
            }

            if (DebugTestButton("NF Import Berenike Anims"))
            {
                var skell = Scene.MainModel.AnimContainer.Skeleton;

                NewHavokAnimation LoadAnimFatcat(string ds3AnimName, HKX.HKXVariation hkxVariation)
                {
                    var ds3animHkx = HKX.Read(ds3AnimName, hkxVariation, false);

                    HKX.HKAAnimationBinding hk_binding = null;
                    HKX.HKASplineCompressedAnimation hk_anim = null;

                    HKX.HKADefaultAnimatedReferenceFrame hk_RefFrame = null;

                    foreach (var o in ds3animHkx.DataSection.Objects)
                    {
                        if (o is HKX.HKAAnimationBinding asBinding)
                            hk_binding = asBinding;
                        else if (o is HKX.HKASplineCompressedAnimation asAnim)
                            hk_anim = asAnim;
                        else if (o is HKX.HKADefaultAnimatedReferenceFrame asRefFrame)
                            hk_RefFrame = asRefFrame;
                    }

                    var ds3Anim = new NewHavokAnimation_SplineCompressed("TestDS3Anim", skell, hk_RefFrame, hk_binding, hk_anim, null, fileSize: -1);
                    return ds3Anim;
                }



                var ds3TaeAnibnd = BND4.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c1190.anibnd.dcx");
                var tae = TAE.Read(ds3TaeAnibnd.Files.FirstOrDefault(ff => ff.ID == 3000000).Bytes);


                var templateDS3 = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS3.xml"));

                tae.ApplyTemplate(templateDS3);

                tae.BigEndian = false;
                tae.Format = TAE.TAEFormat.DS1;

                tae.ChangeTemplateAfterLoading(templateDS1, 0);

                Dictionary<int, int> DummyPolyDS1toDS3Map = new Dictionary<int, int>
                {
                    { 13, 11 },
                };


                int CheckDummyPolyID(int dmyPolyID)
                {
                    if (DummyPolyDS1toDS3Map.ContainsKey(dmyPolyID))
                        return DummyPolyDS1toDS3Map[dmyPolyID];
                    else
                        return dmyPolyID;
                }

                var ds3Tae = new Dictionary<int, TAE.Animation>();
                foreach (var a in tae.Animations)
                {
                    int playsoundByDummyPolyIndex = 0;
                    foreach (var ev in a.Events)
                    {
                        ev.Group = null;
                        if (ev.TypeName == "PlaySound_ByDummyPoly")
                        {
                            //int soundType = Convert.ToInt32(ev.Parameters["SoundType"]);
                            //int soundID = Convert.ToInt32(ev.Parameters["SoundID"]);
                            //int dummyPolyID = CheckDummyPolyID(Convert.ToInt32(ev.Parameters["DummyPolyID"]));
                            //float startTime = ev.StartTime;
                            ev.ApplyTemplate(false, templateDS1[0][129]);
                            ev.Parameters["SlotID"] = playsoundByDummyPolyIndex++;
                            ev.EndTime = ev.StartTime + 2;
                        }

                        if (ev.TypeName.Contains("PlaySound"))
                        {
                            int soundID = Convert.ToInt32(ev.Parameters["SoundID"]);
                            if (soundID >= 119000000)
                            {
                                soundID -= 119000000;
                                soundID += 257000000;
                            }
                            ev.Parameters["SoundID"] = soundID;
                        }

                        if (ev.Parameters.Template.ContainsKey("DummyPolyID"))
                        {
                            int dummyPolyID = CheckDummyPolyID(Convert.ToInt32(ev.Parameters["DummyPolyID"]));
                            ev.Parameters["DummyPolyID"] = dummyPolyID;
                        }
                    }
                    a.EventGroups.Clear();

                    ds3Tae.Add((int)a.ID, a);
                }


                void ImportAnim(string ds3, string ds1)
                {

                    var anim = LoadAnimFatcat($@"E:\DarkSoulsModding_Nightfall\Berenike\{ds3}.hkx", HKX.HKXVariation.HKXDS3);

                    var splineFixer = new HavokRootMotionExtractor(skell);

                    var fixedAnim = splineFixer.ProcessAnimation(anim, new HavokRootMotionExtractor.RootMotionExtractorConfig());

                    int animId = int.Parse(ds3.Replace("a", "").Replace("_", ""));

                    importRemappedAnimLol(fixedAnim, ds1, noTaeEntry: false, animToGetEventsFrom: ds3Tae[animId], newTaeEntryName: $"+{ds1}.hkx");
                }

                ImportAnim("a001_000020", "a02_0000");

                ImportAnim("a001_002000", "a02_0200");
                ImportAnim("a001_002001", "a02_0201");
                ImportAnim("a001_002002", "a02_0202");
                ImportAnim("a001_002003", "a02_0203");

                ImportAnim("a001_002100", "a02_0500");

                for (int i = 0; i <= 20; i++)
                {
                    ImportAnim($"a001_0030{i:D2}", $"a02_30{i:D2}");
                }

                ImportAnim("a001_005000", "a02_0602");
                ImportAnim("a001_005001", "a02_0603");
                ImportAnim("a001_005002", "a02_0604");
                ImportAnim("a001_005003", "a02_0605");

                Console.WriteLine("fatcat");
            }

            //return;

            if (DebugTestButton("ds3 anim port test"))
            {


                var ds3Skel = LoadSkel(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000-anibnd-dcx\chr\c0000\hkx\Skeleton.hkx");

                var sdtSkel = LoadSkel(@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000-anibnd-dcx-2010\chr\c0000\hkx\skeleton.hkx");

                var bbSkel = LoadSkel(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000-anibnd-dcx\chr\c0000\hkx\skeleton.HKX");

                var ds3Skel_c5280 = LoadSkel(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c5150-anibnd-dcx\chr\c5150\hkx\skeleton.HKX");

                var sdtSkel_c5090 = LoadSkel(@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c5090-anibnd-dcx-2010\chr\c5090\hkx_compendium\skeleton.hkx");

                NewHavokAnimation LoadAnimFatcat(string ds3AnimName, HKX.HKXVariation hkxVariation, NewAnimSkeleton_HKX skel = null)
                {
                    var ds3animHkx = HKX.Read(ds3AnimName, hkxVariation, false);

                    HKX.HKAAnimationBinding hk_binding = null;
                    HKX.HKASplineCompressedAnimation hk_anim = null;

                    HKX.HKADefaultAnimatedReferenceFrame hk_RefFrame = null;

                    foreach (var o in ds3animHkx.DataSection.Objects)
                    {
                        if (o is HKX.HKAAnimationBinding asBinding)
                            hk_binding = asBinding;
                        else if (o is HKX.HKASplineCompressedAnimation asAnim)
                            hk_anim = asAnim;
                        else if (o is HKX.HKADefaultAnimatedReferenceFrame asRefFrame)
                            hk_RefFrame = asRefFrame;
                    }

                    var ds3Anim = new NewHavokAnimation_SplineCompressed("TestDS3Anim", skel ?? ds3Skel, hk_RefFrame, hk_binding, hk_anim, null, fileSize: -1);
                    return ds3Anim;
                }

                var ds1Idle00 = Scene.MainModel.AnimContainer.FindAnimation("a00_0000.hkx");
                var ds1Idle10 = Scene.MainModel.AnimContainer.FindAnimation("a10_0000.hkx");
                var ds1Idle12 = Scene.MainModel.AnimContainer.FindAnimation("a12_0000.hkx");

                //var remapper = new HavokSkeletonRemapper(ds3Skel, Scene.MainModel.AnimContainer.Skeleton, new Dictionary<string, string>
                //    {
                //        {  "LCalfTwist", "L_CalfTwist1" },
                //        {  "RCalfTwist", "R_CalfTwist1" },
                //        {  "L_ForeTwist", "L_ForeArmTwist1" },
                //        {  "R_ForeTwist", "R_ForeArmTwist1" },
                //        {  "L_Shoulderpad", "L_Shoulder" },
                //        {  "R_Shoulderpad", "R_Shoulder" },
                //        {  "L_Finger2", "L_Finger3" },
                //        {  "L_Finger21", "L_Finger31" },
                //        {  "L_Finger22", "L_Finger32" },
                //        {  "R_Finger2", "R_Finger3" },
                //        {  "R_Finger21", "R_Finger31" },
                //        {  "R_Finger22", "R_Finger32" },
                //        {  "LUpArmTwist", "L_UpArmTwist" },
                //        {  "RUpArmTwist", "R_UpArmTwist" },
                //        {  "Master", "RootPos" },
                //    }, "Pelvis", "Master");

                //var remapper = new HavokSkeletonRemapper(sdtSkel, Scene.MainModel.AnimContainer.Skeleton, new Dictionary<string, string>
                //    {
                //        {  "LCalfTwist", "L_CalfTwist1" },
                //        {  "RCalfTwist", "R_CalfTwist1" },
                //        {  "L_ForeTwist", "L_ForeArmTwist1" },
                //        {  "R_ForeTwist", "R_ForeArmTwist1" },
                //        {  "L_Shoulderpad", "L_Shoulder" },
                //        {  "R_Shoulderpad", "R_Shoulder" },
                //        {  "L_Finger2", "L_Finger3" },
                //        {  "L_Finger21", "L_Finger31" },
                //        {  "L_Finger22", "L_Finger32" },
                //        {  "R_Finger2", "R_Finger3" },
                //        {  "R_Finger21", "R_Finger31" },
                //        {  "R_Finger22", "R_Finger32" },
                //        {  "LUpArmTwist", "L_UpArmTwist" },
                //        {  "RUpArmTwist", "R_UpArmTwist" },
                //        {  "Master", "RootPos" },
                //    }, "Pelvis", "Master");

                var remapper = new HavokSkeletonRemapper(sdtSkel_c5090, Scene.MainModel.AnimContainer.Skeleton, new Dictionary<string, string>
                    {
                        {  "LCalfTwist", "L_CalfTwist1" },
                        {  "RCalfTwist", "R_CalfTwist1" },
                        {  "L_ForeTwist", "L_ForeArmTwist1" },
                        {  "R_ForeTwist", "R_ForeArmTwist1" },
                        {  "L_Shoulderpad", "L_Shoulder" },
                        {  "R_Shoulderpad", "R_Shoulder" },
                        {  "L_Finger2", "L_Finger3" },
                        {  "L_Finger21", "L_Finger31" },
                        {  "L_Finger22", "L_Finger32" },
                        {  "R_Finger2", "R_Finger3" },
                        {  "R_Finger21", "R_Finger31" },
                        {  "R_Finger22", "R_Finger32" },
                        {  "LUpArmTwist", "L_UpArmTwist" },
                        {  "RUpArmTwist", "R_UpArmTwist" },
                        {  "Master", "Master" },
                    }, "Pelvis", "Master");

                //var remapper = new HavokSkeletonRemapper(bbSkel, Scene.MainModel.AnimContainer.Skeleton, new Dictionary<string, string>
                //    {
                //        {  "LCalfTwist", "Support_L_CalfTwist1" },
                //        {  "RCalfTwist", "Support_R_CalfTwist1" },
                //        {  "L_ForeTwist", "Support_L_ForeArmTwist1" },
                //        {  "R_ForeTwist", "Support_R_ForeArmTwist1" },
                //        {  "L_Shoulderpad", "Support_L_Shoulder" },
                //        {  "R_Shoulderpad", "Support_R_Shoulder" },
                //        {  "L_Finger2", "L_Finger3" },
                //        {  "L_Finger21", "L_Finger31" },
                //        {  "L_Finger22", "L_Finger32" },
                //        {  "R_Finger2", "R_Finger3" },
                //        {  "R_Finger21", "R_Finger31" },
                //        {  "R_Finger22", "R_Finger32" },
                //        {  "LUpArmTwist", "Support_L_UpArmTwist" },
                //        {  "RUpArmTwist", "Support_R_UpArmTwist" },
                //        //{  "Master", "RootPos" },
                //    }, "Pelvis", "Master");

                //var remapper = new HavokSkeletonRemapper(ds3Skel_c5280, Scene.MainModel.AnimContainer.Skeleton, new Dictionary<string, string>
                //    {
                //        //{  "LCalfTwist", "L_CalfTwist1" },
                //        //{  "RCalfTwist", "R_CalfTwist1" },
                //        //{  "L_ForeTwist", "L_ForeArmTwist1" },
                //        //{  "R_ForeTwist", "R_ForeArmTwist1" },
                //        //{  "L_Shoulderpad", "L_Shoulder" },
                //        //{  "R_Shoulderpad", "R_Shoulder" },
                //        //{  "L_Finger2", "L_Finger3" },
                //        //{  "L_Finger21", "L_Finger31" },
                //        //{  "L_Finger22", "L_Finger32" },
                //        //{  "R_Finger2", "R_Finger3" },
                //        //{  "R_Finger21", "R_Finger31" },
                //        //{  "R_Finger22", "R_Finger32" },
                //        //{  "LUpArmTwist", "L_UpArmTwist" },
                //        //{  "RUpArmTwist", "R_UpArmTwist" },

                //        {  "L_Clavicle", "L_ArmCollarbone" },
                //        {  "L_UpperArm", "L_Arm1" },
                //        {  "L_Forearm", "L_Arm2" },
                //        {  "L_Hand", "L_Arm_Hand" },
                //        {  "L_Finger1", "L_Arm_Finger01_1" },
                //        {  "L_Finger11", "L_Arm_Finger01_1" },
                //        {  "L_Finger12", "L_Arm_Finger01_3" },
                //        {  "L_Finger2", "L_Arm_Finger03_1" },
                //        {  "L_Finger21", "L_Arm_Finger03_1" },
                //        {  "L_Finger22", "L_Arm_Finger03_3" },

                //        {  "R_Clavicle", "R_ArmCollarbone" },
                //        {  "R_UpperArm", "R_Arm1" },
                //        {  "R_Forearm", "R_Arm2" },
                //        {  "R_Hand", "R_Arm_Hand" },
                //        {  "R_Finger1", "R_Arm_Finger01_1" },
                //        {  "R_Finger11", "R_Arm_Finger01_1" },
                //        {  "R_Finger12", "R_Arm_Finger01_3" },
                //        {  "R_Finger2", "R_Arm_Finger03_1" },
                //        {  "R_Finger21", "R_Arm_Finger03_1" },
                //        {  "R_Finger22", "R_Arm_Finger03_3" },

                //        {  "R_Weapon", "R_Wepon1" },

                //        {  "Spine", "Spine02" },
                //        {  "Spine1", "Spine03" },

                //        {  "Pelvis", "Spine01" },

                //        {  "Master", "UnderSpine05" },

                //        {  "L_Thigh", "UnderSpine04" },
                //        {  "R_Thigh", "UnderSpine04" },
                //        {  "L_Calf", "UnderSpine03" },
                //        {  "R_Calf", "UnderSpine03" },
                //        {  "L_Foot", "UnderSpine02" },
                //        {  "R_Foot", "UnderSpine02" },

                //        {  "Neck", "Neck1" },

                //}, "Pelvis", "Master");



                void ImportDS3Animation(string ds3AnimName, string ds1AnimName, TAE.Animation animToGetEventsFrom,
                    NewHavokAnimation ds1IdleAnim, NewHavokAnimation ds3IdleAnim, NewHavokAnimation blendToIdleAnim = null, NewHavokAnimation twoHandIdleAnim = null, NewAnimSkeleton_HKX skel = null,
                    HavokSkeletonRemapper.IdleCorrectBlendConfig cfg = null, bool noTaeEntry = false, HKX.HKXVariation? forceHkxType = null)
                {
                    if (cfg == null)
                        cfg = new HavokSkeletonRemapper.IdleCorrectBlendConfig();

                    if (ds1IdleAnim == null)
                        ds1IdleAnim = ds1Idle00;

                    var ds3animHkx = HKX.Read(ds3AnimName, forceHkxType ?? HKX.HKXVariation.HKXDS3, false);

                    HKX.HKAAnimationBinding hk_binding = null;
                    HKX.HKASplineCompressedAnimation hk_anim = null;

                    HKX.HKADefaultAnimatedReferenceFrame hk_RefFrame = null;

                    foreach (var o in ds3animHkx.DataSection.Objects)
                    {
                        if (o is HKX.HKAAnimationBinding asBinding)
                            hk_binding = asBinding;
                        else if (o is HKX.HKASplineCompressedAnimation asAnim)
                            hk_anim = asAnim;
                        else if (o is HKX.HKADefaultAnimatedReferenceFrame asRefFrame)
                            hk_RefFrame = asRefFrame;
                    }





                    var ds3Anim = new NewHavokAnimation_SplineCompressed("TestDS3Anim", skel ?? ds3Skel, hk_RefFrame, hk_binding, hk_anim, null, fileSize: -1);



                    var remappedAnim = remapper.RemapAnim(ds3Anim, ds1IdleAnim, ds3IdleAnim, blendToIdleAnim, twoHandIdleAnim, cfg);

                    //remappedAnim.WriteToHavok2010InterleavedUncompressedXMLFile("punches uncompressed.xml");

                    importRemappedAnimLol(remappedAnim, ds1AnimName, noTaeEntry, animToGetEventsFrom, "[IMPORTED]" + animToGetEventsFrom.AnimFileName);
                }

                //void RemapDS1Idle(NewHavokAnimation origDS1Idle, string ds1AnimName, NewHavokAnimation ds1IdleAnim, NewHavokAnimation ds3IdleAnim)
                //    {
                //        if (ds1IdleAnim == null)
                //            ds1IdleAnim = ds1Idle00;

                //        var remappedAnim = remapper.RemapAnim(origDS1Idle, ds1IdleAnim, ds3IdleAnim, null, null, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(996, 997, 998, 999),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(996, 997, 998, 999),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(996, 997, 998, 999),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 998, 999),
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 998, 999),
                //        });

                //        //remappedAnim.WriteToHavok2010InterleavedUncompressedXMLFile("punches uncompressed.xml");

                //        var readyForGame = ImportedAnimationConverter.GetAnimReadyToPutIntoGameFromImported(remappedAnim);



                //        if (ds1AnimName.ToLower().EndsWith(".hkx"))
                //            ds1AnimName = ds1AnimName.Substring(0, ds1AnimName.Length - 4);

                //        if (int.TryParse(ds1AnimName.Replace("a", "").Replace("_", ""), out int id))
                //        {
                //            var shortName = ds1AnimName;

                //            var splitID = GameDataManager.SplitAnimID.FromFullID(id);

                //            if (GameDataManager.CurrentAnimIDFormatType == GameDataManager.AnimIDFormattingType.aXX_YYYY)
                //            {
                //                shortName = $"a{splitID.TaeID:D2}_{splitID.SubID:D4}";
                //            }
                //            else if (GameDataManager.CurrentAnimIDFormatType == GameDataManager.AnimIDFormattingType.aXXX_YYYYYY)
                //            {
                //                shortName = $"a{splitID.TaeID:D3}_{splitID.SubID:D6}";
                //            }
                //            else if (GameDataManager.CurrentAnimIDFormatType == GameDataManager.AnimIDFormattingType.aXX_YY_ZZZZ)
                //            {
                //                shortName = $"a{splitID.TaeID:D3}_{splitID.SubID:D6}";
                //                shortName.Insert(6, "_");
                //            }
                //            else
                //            {
                //                throw new NotImplementedException();
                //            }

                //            mainScreen.FileContainer.AddNewHKX(shortName, readyForGame.DataForGame, out byte[] dataForAnimContainer, readyForGame.Data2010);

                //            if (dataForAnimContainer == null)
                //            {
                //                DialogManager.DialogOK("Failed", "Failed to save (TagTools refused to work), just try again.");
                //                return;
                //            }

                //            mainScreen.Graph.ViewportInteractor.CurrentModel.AnimContainer.AddNewHKXToLoad(shortName + ".hkx", readyForGame.Data2010);
                //            mainScreen.ReselectCurrentAnimation();
                //            mainScreen.HardReset();

                //            //DialogManager.DialogOK("Import Complete", $"Finished importing animation HKX and TAE.");
                //        }
                //    }


                var sdtTae = new Dictionary<int, Dictionary<int, TAE.Animation>>();
                var bbTae = new Dictionary<int, Dictionary<int, TAE.Animation>>();

                if (!File.Exists($@"{Main.Directory}\lib\oo2core_6_win64.dll"))
                    File.Copy(@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\oo2core_6_win64.dll", $@"{Main.Directory}\lib\oo2core_6_win64.dll");


                var sdtTaeAnibnd = BND4.Read(@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000.anibnd.dcx");
                var bbTaeAnibnd = BND4.Read(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000.anibnd.dcx");



                var ds3TaeAnibnd = BND4.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000.anibnd.dcx");
                var ds3Tae = new Dictionary<int, Dictionary<int, TAE.Animation>>();
                void LoadDS3Tae(int id)
                {
                    var tae = TAE.Read(ds3TaeAnibnd.Files.FirstOrDefault(ff => ff.ID == 5000000 + id).Bytes);

                    var templateDS1 = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS1.xml"));
                    var templateDS3 = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS3.xml"));

                    tae.ApplyTemplate(templateDS3);

                    tae.BigEndian = false;
                    tae.Format = TAE.TAEFormat.DS1;

                    tae.ChangeTemplateAfterLoading(templateDS1, 0);

                    var anims = new Dictionary<int, TAE.Animation>();
                    foreach (var a in tae.Animations)
                    {
                        anims.Add((int)a.ID, a);
                    }

                    ds3Tae.Add(id, anims);
                }

                void LoadBBTae(int id)
                {
                    var tae = TAE.Read(bbTaeAnibnd.Files.FirstOrDefault(ff => ff.ID == 5000000 + id).Bytes);

                    var templateDS1 = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS1.xml"));
                    var templateBB = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS3.xml"));

                    tae.ApplyTemplate(templateBB);

                    tae.BigEndian = false;
                    tae.Format = TAE.TAEFormat.DS1;

                    tae.ChangeTemplateAfterLoading(templateDS1, 0);

                    var anims = new Dictionary<int, TAE.Animation>();
                    foreach (var a in tae.Animations)
                    {
                        anims.Add((int)a.ID, a);
                    }

                    bbTae.Add(id, anims);
                }

                void LoadSDTTae(int id)
                {
                    var tae = TAE.Read(sdtTaeAnibnd.Files.FirstOrDefault(ff => ff.ID == 5000000 + id).Bytes);

                    var templateDS1 = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS1.xml"));
                    var templateSDT = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.SDT.xml"));

                    tae.ApplyTemplate(templateSDT);

                    tae.BigEndian = false;
                    tae.Format = TAE.TAEFormat.DS1;

                    tae.ChangeTemplateAfterLoading(templateDS1, 0);

                    var anims = new Dictionary<int, TAE.Animation>();
                    foreach (var a in tae.Animations)
                    {
                        anims.Add((int)a.ID, a);
                    }

                    sdtTae.Add(id, anims);
                }

                LoadDS3Tae(152);
                LoadDS3Tae(700);
                LoadDS3Tae(804);
                LoadDS3Tae(808);
                LoadDS3Tae(721);
                LoadDS3Tae(821);



                var ds3Idle00 = LoadAnimFatcat(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_a4x-anibnd-dcx\chr\c0000\hkx\a042\a042_033000.hkx", HKX.HKXVariation.HKXDS3);
                var ds3Idle00BB = LoadAnimFatcat(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a700\lo\a700_000000.hkx", HKX.HKXVariation.HKXDS3);

                var ds3IdleHollowBB = LoadAnimFatcat(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a700\hi\a700_103072.hkx", HKX.HKXVariation.HKXDS3);

                var sdtIdle00 = LoadAnimFatcat(@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a000_lo-anibnd-dcx-2010\chr\c0000\hkx\a000_lo_compendium\a000_000000.hkx", HKX.HKXVariation.HKXDS1, skel: sdtSkel);

                var ds3Idle00_c5280 = LoadAnimFatcat(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c5150-anibnd-dcx\chr\c5150\hkx\a000_000020.HKX", HKX.HKXVariation.HKXDS3, skel: ds3Skel_c5280);

                var bbIdle00 = LoadAnimFatcat(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a00_lo-anibnd-dcx\chr\c0000\hkx\a000\a000_000000.hkx", HKX.HKXVariation.HKXBloodBorne);

                var sdtIdle00_c5090 = LoadAnimFatcat(@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c5090-anibnd-dcx-2010\chr\c5090\hkx_compendium\a000_003008.hkx", HKX.HKXVariation.HKXDS1, skel: sdtSkel_c5090);

                void DoBBAnim(int t, int a, string ds1AnimName, NewHavokAnimation ds1Idle, HavokSkeletonRemapper.IdleCorrectBlendConfig idleCorrectBlendConfig, NewHavokAnimation overrideBBSourceIdle = null)
                {
                    if (!ds3Tae.ContainsKey(t))
                        LoadDS3Tae(t);

                    string meme = "";

                    if (t == 700)
                    {
                        if (a >= 9000)
                            meme = @"hi\";
                        else if (a >= 5000)
                            meme = @"md\";
                        else
                            meme = @"lo\";
                    }

                    ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a{t:D3}\{meme}a{t:D3}_{a:D6}.hkx",
                        ds1AnimName, ds3Tae[t][a], ds1Idle00, overrideBBSourceIdle ?? ds3Idle00BB, ds1Idle, cfg: idleCorrectBlendConfig);
                }

                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a808\a808_041000.hkx", "a42_4000", ds3Tae[808][041000], ds1Idle00, ds3Idle00BB, 0.2f, 1.0f, ignoreArmIdleRemap: true);
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a808\a808_041100.hkx", "a42_4001", ds3Tae[808][041100], ds1Idle00, ds3Idle00BB, -1, 1.0f, ignoreArmIdleRemap: true);
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a808\a808_041200.hkx", "a42_4002", ds3Tae[808][041200], ds1Idle00, ds3Idle00BB, -1, 1.0f, ignoreArmIdleRemap: true);
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a808\a808_042100.hkx", "a42_4003", ds3Tae[808][042100], ds1Idle00, ds3Idle00BB, -1, 1.0f, ignoreArmIdleRemap: true);
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_dlc2-anibnd-dcx\chr\c0000\hkx\a808\a808_042150.hkx", "a42_4004", ds3Tae[808][042150], ds1Idle00, ds3Idle00BB, -1, 1.0f, ignoreArmIdleRemap: true);
                //
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_a4x-anibnd-dcx\chr\c0000\hkx\a042\a042_033000.hkx", "a42_5300", ds3Tae[152][033000], ds1Idle00, ds3Idle00);
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_a4x-anibnd-dcx\chr\c0000\hkx\a042\a042_033010.hkx", "a42_5310", ds3Tae[152][033010], ds1Idle00, ds3Idle00);
                //
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_a9x-anibnd-dcx\chr\c0000\hkx\a152\a152_036400.hkx", "a42_4300", ds3Tae[152][036400], ds1Idle00, ds3Idle00);
                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000_a9x-anibnd-dcx\chr\c0000\hkx\a152\a152_036420.hkx", "a42_4310", ds3Tae[152][036420], ds1Idle00, ds3Idle00);

                //ImportDS3Animation(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c0000-anibnd-dcx\a700_100151.hkx", "a00_7573", ds3Tae[700][100151], ds1Idle00, ds3Idle00);

                //DoBBAnim(842, 030000, "a32_4000", ds1Idle12, 0.2f, 1.0f);
                //DoBBAnim(842, 030200, "a32_4001", ds1Idle12, 0.2f, 1.0f);
                //DoBBAnim(842, 030300, "a32_4002", ds1Idle12, 0.2f, 1.0f);
                //DoBBAnim(842, 030010, "a32_4003", ds1Idle12, 0.2f, 1.0f);
                //DoBBAnim(842, 030100, "a32_4004", ds1Idle12, 0.2f, 1.0f);

                //DoBBAnim(700, 103070, "a00_7574", ds1Idle00, -1, -1, ds3IdleHollowBB);
                //DoBBAnim(700, 103071, "a00_7575", ds1Idle00, -1, -1, ds3IdleHollowBB);



                LoadSDTTae(107);
                LoadSDTTae(108);

                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c5150-anibnd-dcx\chr\c5150\hkx\a000_003006.hkx",
                //        "a00_3000", sdtTae[107][316030], ds1Idle00, ds3Idle00_c5280, 

                //        blendToIdleAnim: ds1Idle00,
                //        twoHandIdleAnim: ds1Idle10, 

                //        skel: ds3Skel_c5280, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 999, 999),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 999, 999),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 999, 999),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 999, 999),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 999, 999),
                //            IsTwoHandWeaponIKFix_LeftHand = false,
                //            TwoHandWeaponIKFix_LeftHandCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 40, 44),
                //            SourceSkeletonScale = 1.6f / 15f,
                //            RaiseMasterUpToPelvis = true,
                //        }, noTaeEntry: true);

                LoadBBTae(108);

                //Dictionary<int, int> moveTaeAnimIDMap_BB = new Dictionary<int, int>
                //{
                //    { 0000, 000000 },
                //    { 0200, 003000 },
                //    { 0201, 003001 },
                //    { 0202, 003002 },
                //    { 0203, 003003 },
                //    { 0500, 004000 },
                //    { 0501, 004001 },
                //    { 0502, 004002 },
                //    { 0503, 004003 },
                //    { 0510, 005000 },
                //};

                // Generate BB Idles

                LoadDS3Tae(803);

                ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c5090-anibnd-dcx-2010\chr\c5090\hkx_compendium\a000_003065.hkx",
                        //$@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a2x-anibnd-dcx\chr\c0000\hkx\a021\a021_000000.hkx",
                        "a137_5001", sdtTae[108][316010], ds1Idle00, sdtIdle00_c5090,

                        blendToIdleAnim: ds1Idle00,
                        twoHandIdleAnim: ds1Idle00,

                        skel: sdtSkel_c5090,

                        new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                        {
                            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(14, 19, 65, 85, (Out: 1, In: 0)),
                            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 22, 75, 85, (Out: 1, In: 0)),
                            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, 84, 88, (Out: 1, In: 0)),
                            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, 84, 88, (Out: 1, In: 0)),
                            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, 84, 88, (Out: 1, In: 0)),

                            SourceSkeletonScale = 1.6f / 1.8f,
                            RaiseMasterUpToPelvis = true,
                            //SourceBoneAbsCorrectMatrices = new Dictionary<string, Matrix>
                            //{
                            //    { "Pelvis", Matrix.CreateRotationZ(MathHelper.Pi) },
                            //    { "R_Weapon", Matrix.CreateRotationZ(MathHelper.Pi) },
                            //},
                            ArmIK = new HavokSkeletonRemapper.ArmIKConfig()
                            {
                                L_Enabled = false,
                                L_Envelope = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 21, 28, (Out: 0, In: 1)),
                                L_Elbow = "L_Elbow",
                                L_OffsetScale = 1,
                            },

                            MirrorAnimation = false,

                            EndFullIdleBlendEnvelopeFrames = 2
                        }, noTaeEntry: true, forceHkxType: HKX.HKXVariation.HKXDS1);

                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a07x-anibnd-dcx-2010\chr\c0000\hkx\a07x_compendium\a108_316010.hkx",
                //        //$@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a2x-anibnd-dcx\chr\c0000\hkx\a021\a021_000000.hkx",
                //        "a137_4013", sdtTae[108][316010], ds1Idle00, sdtIdle00,

                //        blendToIdleAnim: ds1Idle00,
                //        twoHandIdleAnim: ds1Idle00,

                //        skel: sdtSkel,

                //        new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 78, 85, (Out: 1, In: 0)),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 63, 73, (Out: 1, In: 0)),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 78, 88, (Out: 1, In: 0)),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 78, 88, (Out: 1, In: 0)),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, 78, 88, (Out: 1, In: 0)),

                //            SourceSkeletonScale = 1,
                //            RaiseMasterUpToPelvis = false,
                //            //SourceBoneAbsCorrectMatrices = new Dictionary<string, Matrix>
                //            //{
                //            //    { "Pelvis", Matrix.CreateRotationZ(MathHelper.Pi) },
                //            //    { "R_Weapon", Matrix.CreateRotationZ(MathHelper.Pi) },
                //            //},
                //            ArmIK = new HavokSkeletonRemapper.ArmIKConfig()
                //            {
                //                L_Enabled = false,
                //                L_Envelope = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 21, 28, (Out: 0, In: 1)),
                //                L_Elbow = "L_Elbow",
                //                L_OffsetScale = 1,
                //            },

                //            MirrorAnimation = true,
                //        }, noTaeEntry: false, forceHkxType: HKX.HKXVariation.HKXDS1);

                //ImportDS3Animation(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a9x-anibnd-dcx\chr\c0000\hkx\a103\a103_040000.hkx",
                //        //$@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a2x-anibnd-dcx\chr\c0000\hkx\a021\a021_000000.hkx",
                //        "a11_0000", ds3Tae[803][040000], ds1Idle00, bbIdle00,

                //        blendToIdleAnim: ds1Idle00,
                //        twoHandIdleAnim: ds1Idle00,

                //        skel: bbSkel,

                //        new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, -20, -1, (Out: 0, In: 0)),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, -20, -1, (Out: 0, In: 0)),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, -20, -1, (Out: 0, In: 0)),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, -20, -1, (Out: 0, In: 0)),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, -20, -1, (Out: 0, In: 0)),

                //            SourceSkeletonScale = 1,
                //            RaiseMasterUpToPelvis = false,
                //            SourceBoneAbsCorrectMatrices = new Dictionary<string, Matrix>
                //            {
                //                { "Pelvis", Matrix.CreateRotationZ(MathHelper.Pi) },
                //                { "R_Weapon", Matrix.CreateRotationZ(MathHelper.Pi) },
                //            },
                //            ArmIK = new HavokSkeletonRemapper.ArmIKConfig()
                //            {
                //                L_Enabled = true,
                //                L_Envelope = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 21, 28, (Out: 0, In: 1)),
                //                L_Elbow = "Support_L_Elbow",
                //                L_OffsetScale = 1,
                //            },
                //        }, noTaeEntry: false, forceHkxType: HKX.HKXVariation.HKXBloodBorne);

                //ImportDS3Animation(@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a9x-anibnd-dcx\chr\c0000\hkx\a103\a103_040000.hkx",
                //        //$@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a2x-anibnd-dcx\chr\c0000\hkx\a021\a021_000000.hkx",
                //        "a11_0001", ds3Tae[803][040000], ds1Idle00, bbIdle00,

                //        blendToIdleAnim: ds1Idle00,
                //        twoHandIdleAnim: ds1Idle00,

                //        skel: bbSkel,

                //        new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(999, 999, -20, -1, (Out: 0, In: 0)),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(999, 999, -20, -1, (Out: 0, In: 0)),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(999, 999, -20, -1, (Out: 0, In: 0)),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(999, 999, -20, -1, (Out: 0, In: 0)),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(999, 999, -20, -1, (Out: 0, In: 0)),
                //            SourceSkeletonScale = 0.95f,
                //            RaiseMasterUpToPelvis = false,
                //            SourceBoneAbsCorrectMatrices = new Dictionary<string, Matrix>
                //            {
                //                { "Pelvis", Matrix.CreateRotationZ(MathHelper.Pi) },
                //                { "R_Weapon", Matrix.CreateRotationZ(MathHelper.Pi) },
                //            },
                //            ArmIK = new HavokSkeletonRemapper.ArmIKConfig()
                //            {
                //                L_Enabled = false,
                //                L_Envelope = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 21, 28, (Out: 0, In: 1)),
                //                L_Elbow = "Support_L_Elbow",
                //                L_OffsetScale = 1,
                //            },
                //        }, noTaeEntry: false, forceHkxType: HKX.HKXVariation.HKXBloodBorne);

                // BB FISTS

                //ImportDS3Animation($@"E:\PS4\CUSA03173-app\dvdroot_ps4\chr\c0000_a9x-anibnd-dcx\chr\c0000\hkx\a108\a108_041000.hkx",
                //        "a42_4000", bbTae[108][041000], ds1Idle00, bbIdle00,

                //        blendToIdleAnim: ds1Idle00,
                //        twoHandIdleAnim: ds1Idle10,

                //        skel: ds3Skel_c5280, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 999, 999),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 999, 999),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, -20, -1),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, -20, -1),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, -20, -1),
                //            IsTwoHandWeaponIKFix_LeftHand = false,
                //            TwoHandWeaponIKFix_LeftHandCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 40, 44),
                //            SourceSkeletonScale = 1,
                //            RaiseMasterUpToPelvis = false,
                //        }, noTaeEntry: true);

                //////////////////////////////



                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a07x-anibnd-dcx-2010\chr\c0000\hkx\a07x_compendium\a107_316010.hkx",
                //        "a42_4000", sdtTae[107][316010], ds1Idle00, sdtIdle00, ds1Idle00, sdtSkel, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(34, 42, 95, 105),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 99, 109),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 84, 118),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 84, 118),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 92, 118),
                //        }, noTaeEntry: true);

                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a07x-anibnd-dcx-2010\chr\c0000\hkx\a07x_compendium\a107_316030.hkx",
                //        "a42_4004", sdtTae[107][316030], ds1Idle00, sdtIdle00, ds1Idle00, skel: sdtSkel, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 119, 126),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 102, 110),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 96, 118),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 89, 118),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 88, 118),
                //        }, noTaeEntry: true);

                ////Done
                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a07x-anibnd-dcx-2010\chr\c0000\hkx\a07x_compendium\a108_316000.hkx",
                //        "a42_4000", sdtTae[108][316000], ds1Idle00, sdtIdle00, ds1Idle00, skel: sdtSkel, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(2, 10, 102, 112),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(2, 10, 116, 123),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 105, 125),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 105, 125),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 8, 96, 114),
                //        }, noTaeEntry: true);

                //Done
                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a07x-anibnd-dcx-2010\chr\c0000\hkx\a07x_compendium\a108_316100.hkx",
                //        "a42_4001", sdtTae[108][316100], ds1Idle00, sdtIdle00, ds1Idle00, skel: sdtSkel, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 55, 65),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 52, 62),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 61, 81),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 61, 81),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 55, 65),
                //        }, noTaeEntry: true);

                //Done
                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a07x-anibnd-dcx-2010\chr\c0000\hkx\a07x_compendium\a108_316010.hkx",
                //        "a42_4002", sdtTae[108][316010], ds1Idle00, sdtIdle00, ds1Idle00, skel: sdtSkel, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 63, 73),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 80, 86),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 72, 102),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 72, 102),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 74, 94),
                //        }, noTaeEntry: true);

                ////Done
                //ImportDS3Animation($@"C:\Program Files (x86)\Steam\steamapps\common\Sekiro\chr\c0000_a07x-anibnd-dcx-2010\chr\c0000\hkx\a07x_compendium\a108_316020.hkx",
                //        "a42_4003", sdtTae[108][316020], ds1Idle00, sdtIdle00, ds1Idle00, skel: sdtSkel, new HavokSkeletonRemapper.IdleCorrectBlendConfig()
                //        {
                //            LeftLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 67, 77),
                //            RightLegCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 79, 89),
                //            LeftArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 61, 88),
                //            RightArmCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 61, 88),
                //            CoreCorrect = new HavokSkeletonRemapper.IdleCorrectEnvelope(0, 0, 61, 88),
                //        }, noTaeEntry: true);

                //void DoBBMoveset(int bbMovesetID, int ds1MovesetID)
                //{

                //}


                mainScreen.RecreateAnimList();

                Console.WriteLine("Fatcat");
            }



            if (DebugTestButton("fix c2250 ffx conflict"))
            {
                var taeScreen = Main.TAE_EDITOR;
                var tae = taeScreen.SelectedTae;
                foreach (var anim in tae.Animations)
                {
                    var newEvents = new List<TAE.Event>();
                    foreach (var ev in anim.Events)
                    {
                        if (ev.TypeName.StartsWith("SpawnFFX"))
                        {
                            int ffxid = Convert.ToInt32(ev.Parameters["FFXID"]);
                            if (ffxid > 1225000 && ffxid < 1225100)
                            {
                                ev.Parameters["FFXID"] = ffxid + 100;
                                anim.SetIsModified(true);
                            }
                        }
                    }


                }

                Console.Write("FATCT");
            }

            if (DebugTestButton("c2250 add new power within shit"))
            {
                var powerWithinSfx = 20221;
                var taeScreen = Main.TAE_EDITOR;
                var tae = taeScreen.SelectedTae;
                foreach (var anim in tae.Animations)
                {
                    var newEvents = new List<TAE.Event>();
                    foreach (var ev in anim.Events)
                    {
                        if (ev.TypeName.StartsWith("SpawnFFX"))
                        {
                            var slot = -1;
                            if (ev.Parameters.Template.ContainsKey("SlotID"))
                            {
                                slot = Convert.ToInt32(ev.Parameters["SlotID"]);
                            }
                            //else if (ev.Parameters.Template.ContainsKey("SlotID"))
                            //{
                            //    slot = Convert.ToInt32(ev.Parameters["SlotID"]);
                            //}

                            if (slot == 2)
                            {
                                var clone = ev.GetClone(GameRoot.IsBigEndianGame);
                                if (Convert.ToInt32(clone.Parameters["FFXID"]) == 1225010)
                                    clone.Parameters["FFXID"] = 20221;
                                clone.Parameters["DummyPolyID"] = 200;
                                clone.Parameters["SlotID"] = 1;
                                newEvents.Add(clone);
                            }
                        }
                    }

                    foreach (var ev in newEvents)
                    {
                        anim.Events.Add(ev);
                    }

                    anim.Events.RemoveAll(ev => ev.TypeName == "InvokeBulletBehavior" && Convert.ToInt32(ev.Parameters["BehaviorJudgeID"]) == 502);

                    anim.SetIsModified(true);
                }
            }

            if (DebugTestButton("nf c2250 anims"))
            {
                var taeScreen = Main.TAE_EDITOR;
                var tae = taeScreen.SelectedTae;

                var phase2Anims = tae.Animations.Where(a => a.ID >= 1_0000 && a.ID < 2_0000).ToList();
                tae.Animations.RemoveAll(a => a.ID >= 2_0000 && a.ID < 3_0000);
                foreach (var a in phase2Anims)
                {
                    var idPhase3 = (a.ID % 1_0000) + 2_0000;
                    var newAnim = new TAE.Animation(idPhase3, new TAE.Animation.AnimMiniHeader.Standard(), "[P3]" + a.AnimFileName);
                    if (a.MiniHeader is TAE.Animation.AnimMiniHeader.ImportOtherAnim asImport)
                    {
                        var newHeader = new TAE.Animation.AnimMiniHeader.ImportOtherAnim();
                        if (asImport.ImportFromAnimID >= 1_0000 && asImport.ImportFromAnimID < 2_0000)
                            newHeader.ImportFromAnimID = (asImport.ImportFromAnimID % 1_0000) + 2_0000;
                        else
                            newHeader.ImportFromAnimID = asImport.ImportFromAnimID;
                        newHeader.Unknown = asImport.Unknown;
                        newAnim.MiniHeader = newHeader;
                    }
                    else
                    {
                        taeScreen.ImmediateImportAnim(newAnim, (int)a.ID);
                    }

                    a.Events.RemoveAll(ev => ev.TypeName == "InvokeBulletBehavior" && Convert.ToInt32(ev.Parameters["BehaviorJudgeID"]) == 502);

                    tae.Animations.Add(newAnim);
                }

                taeScreen.RecreateAnimList();
            }


            if (DebugTestButton("nf c2250 DummyPoly generate"))
            {
                var bnd = BND3.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2250.chrbnd.dcx");
                var flverFile = bnd.Files.First(f => f.Name.ToLower().EndsWith(".flver"));
                var flver = FLVER2.Read(flverFile.Bytes);

                flver.Dummies.RemoveAll(dmy => dmy.ReferenceID == 100);
                flver.Dummies.RemoveAll(dmy => dmy.ReferenceID == 101);
                flver.Dummies.RemoveAll(dmy => dmy.ReferenceID == 102);
                flver.Dummies.RemoveAll(dmy => dmy.ReferenceID == 14);

                var eyePositions = new List<NVector3>
                {
                    //new NVector3(-0.1870f, 1.6162f, 3.9389f),
                    //new NVector3(-0.2685f, 1.5294f, 4.0075f),
                    //new NVector3(-0.3320f, 1.4657f, 4.1280f),

                    new NVector3(0.28379f, 1.47078f, 4.12601f),
                    new NVector3(0.24592f, 1.5207f, 4.0061f),
                    new NVector3(0.1595f, 1.61781f, 3.93371f),

                    new NVector3(-0.28379f, 1.47078f, 4.12601f),
                    new NVector3(-0.24592f, 1.5207f, 4.0061f),
                    new NVector3(-0.1595f, 1.61781f, 3.93371f),
                };

                var baseDummyPoly = flver.Dummies.First(d => d.ReferenceID == 7);
                foreach (var pos in eyePositions)
                {
                    var dmy = baseDummyPoly.GetClone();
                    dmy.Position = NVector3.Transform(pos, NMatrix.CreateRotationX(-MathHelper.PiOver2));
                    dmy.ReferenceID = 100;
                    flver.Dummies.Add(dmy);
                }

                var core = flver.Dummies.First(d => d.ReferenceID == 13).GetClone();
                core.Position = new NVector3(3.6053f, 3.73005f, -4.56867f);
                core.ReferenceID = 14;
                flver.Dummies.Add(core);

                var allBodyVertices = flver.Meshes[0].Vertices
                    .Concat(flver.Meshes[1].Vertices)
                    .Concat(flver.Meshes[2].Vertices)
                    .Concat(flver.Meshes[3].Vertices)
                    .Concat(flver.Meshes[4].Vertices)
                    .Concat(flver.Meshes[5].Vertices)
                    .ToList();

                var dmy200 = flver.Dummies.Where(d => d.ReferenceID == 200).ToList();

                foreach (var d in dmy200)
                {
                    var closestVertex = allBodyVertices.OrderBy(v => (v.Position - d.Position).LengthSquared()).First();

                    FLVER2.Mesh meshThatContainsClosestVertex = null;
                    for (int i = 0; i < 6; i++)
                    {
                        if (flver.Meshes[i].Vertices.Contains(closestVertex))
                        {
                            meshThatContainsClosestVertex = flver.Meshes[i];
                            break;
                        }
                    }

                    int strongestBoneIndex = -1;
                    float strongestBoneWeight = -1;

                    for (int i = 0; i < 4; i++)
                    {
                        if (closestVertex.BoneWeights[i] > strongestBoneWeight)
                        {
                            strongestBoneWeight = closestVertex.BoneWeights[i];
                            strongestBoneIndex = meshThatContainsClosestVertex.BoneIndices[closestVertex.BoneIndices[i]];
                        }
                    }

                    d.AttachBoneIndex = (short)strongestBoneIndex;

                    d.Position = closestVertex.Position;
                }

                var dmy200ForFlames = dmy200
                    .Where(d => d.Position.Z > -0.5f)
                    .Where(d => d.Position.Y >= 4.15f)
                    .ToList();

                foreach (var d in dmy200ForFlames)
                {
                    var c = d.GetClone();
                    c.ReferenceID = 101;
                    c.Position = c.Position * 0.95f;
                    flver.Dummies.Add(c);
                }

                var mainRunes = flver.Dummies.Where(d => d.ReferenceID == 228).OrderByDescending(d => d.Position.Y).Skip(1).First();

                var cRunes = mainRunes.GetClone();
                cRunes.ReferenceID = 102;
                flver.Dummies.Add(cRunes);

                //foreach (var b in flver.Bones)
                //{
                //    if (b.Name == "master エクストラ01Nub")
                //    {
                //        b.Name = "FuckYouFromSoft_FatCat";
                //        var jaw = flver.Bones.Find(j => j.Name == "jaw");
                //        b.Translation -= jaw.Translation;
                //        b.ParentIndex = (short)flver.Bones.IndexOf(jaw);
                //        b.Unk3C = 0;
                //    }
                //}




                flverFile.Bytes = flver.Write();

                bnd.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2250.chrbnd.dcx");

                Console.WriteLine("fatcat");
            }

            if (false && DebugTestButton("Fix c2250 Japanese"))
            {
                var flver = FLVER2.Read(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2250JpnFix\c2250-chrbnd\chr\c2250\c2250.flver");
                foreach (var b in flver.Bones)
                {
                    if (b.Name == "master エクストラ01Nub")
                    {
                        b.Name = "FuckYouFromSoft_FatCat";
                    }
                }
                flver.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\chr\c2250JpnFix\c2250-chrbnd\chr\c2250\c2250_FixTest.flver");
                Console.WriteLine("Success probably");
            }

            //if (DebugTestButton("Export current anim as 60 Hz uncompressed XML"))
            //{
            //    Scene.MainModel.AnimContainer.CurrentAnimation.
            //}


            if (false && DebugTestButton("Misc2"))
            {
                var test = new Dictionary<string, FLVER2>();
                var mapFlverNames = Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\map", "*.flver.dcx", SearchOption.AllDirectories);
                foreach (var ff in mapFlverNames)
                {
                    var flver = FLVER2.Read(ff);
                    foreach (var mat in flver.Materials)
                    {
                        if (mat.MTD.ToLower().EndsWith("m[d][l].mtd"))
                        {
                            test.Add(Path.GetFileName(ff), flver);
                            break;
                        }
                    }
                }

                Console.WriteLine("fatcsat");
            }

            if (false && DebugTestButton("anim id red test"))
            {
                zzz_DocumentManager.CurrentDocument.EditorScreen.SelectedTaeAnim.ID = -1234567899999999999;
                zzz_DocumentManager.CurrentDocument.EditorScreen.RecreateAnimList();
            }

            if (false && DebugTestButton("hoodie test"))
            {
                var bndPath_ORIG = @"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS III\Game\chr\c5280.chrbnd.dcx";
                var bnd_ORIG = BND4.Read(bndPath_ORIG);
                var flver_orig = FLVER2.Read(bnd_ORIG.Files.First(x => x.Name.ToLower().EndsWith(".flver")).Bytes);


                var fbx = @"E:\DarkSoulsModding\_FBX_ANIM\Floppyfbxparent.FBX";
                var settings = new FLVER2Importer.FLVER2ImportSettings()
                {
                    AssetPath = fbx,
                    ConvertFromZUp = true,
                    SceneScale = 1,
                    FlverHeader = flver_orig.Header,
                    Game = SoulsAssetPipeline.SoulsGames.DS3,
                    RootNodeName = "Bone001",
                    //SkeletonTransformsOverride = flver_orig.Bones,
                    //SceneCorrectMatrix = System.Numerics.Matrix4x4.CreateRotationY(SoulsAssetPipeline.SapMath.Pi),
                    //BoneNameRemapper = new Dictionary<string, string>
                    //{
                    //    { "Pelvis001", "Pelvis" },
                    //}
                };

                var importer = new FLVER2Importer();
                var imp = importer.ImportFBX(fbx, settings);

                imp.Flver.Write($"{Main.Directory}\\floppy.flver");

                Console.WriteLine("fatcat");
            }


            if (false && DebugTestButton("Misc"))
            {
                var test = @"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\map\m10_02_00_00\m4100B2A10_Crash.flver";
                var flver = FLVER2.Read(test);

                //foreach (var m in flver.Meshes)
                //{
                //    foreach (var v in m.Vertices)
                //    {
                //        if (v.Tangents.Count == 0)
                //            v.Tangents.Add(new NVector4(NVector3.TransformNormal(v.Normal, NMatrix.CreateRotationZ(MathHelper.PiOver2)), 1));

                //        v.NormalW = 0;
                //    }

                //    foreach (var vb in m.VertexBuffers)
                //    {
                //        vb.LayoutIndex = 0;
                //    }

                //    var fs = m.FaceSets[0];
                //    var new1 = new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.LodLevel1, fs.TriangleStrip, fs.CullBackfaces, fs.Unk06, fs.Indices.ToList());
                //    var new2 = new FLVER2.FaceSet(FLVER2.FaceSet.FSFlags.LodLevel2, fs.TriangleStrip, fs.CullBackfaces, fs.Unk06, fs.Indices.ToList());

                //    m.FaceSets.Add(new1);
                //    m.FaceSets.Add(new2);
                //}

                //flver.BufferLayouts = flver.BufferLayouts.Take(1).ToList();

                //foreach (var layout in flver.BufferLayouts)
                //{
                //    if (!layout.Any(mb => mb.Semantic == FLVER.LayoutSemantic.Tangent))
                //    {
                //        var normalIndex = layout.FindIndex(mb => mb.Semantic == FLVER.LayoutSemantic.Normal);
                //        if (normalIndex >= 0)
                //        {
                //            var n = layout[normalIndex];
                //            var newMember = new FLVER.LayoutMember(n.Type, FLVER.LayoutSemantic.Tangent, 0, n.Unk00);
                //            layout.Insert(normalIndex + 1, newMember);
                //        }
                //    }
                //}

                //int xx = 0;

                //foreach (var m in flver.Materials)
                //{
                //    m.GXIndex = -1;
                //    var g_Lightmap_Index = m.Textures.FindIndex(tx => tx.Type == "g_Lightmap");
                //    if (g_Lightmap_Index >= 0)
                //    {
                //        var lm = m.Textures[g_Lightmap_Index];
                //        var g_Specular = new FLVER2.Texture("g_Specular", lm.Path, lm.Scale, lm.Unk10, lm.Unk11, 0, 0, lm.Unk1C);
                //        var g_Bumpmap = new FLVER2.Texture("g_Bumpmap", lm.Path, lm.Scale, lm.Unk10, lm.Unk11, 0, 0, lm.Unk1C);
                //        m.Textures.Insert(g_Lightmap_Index, g_Bumpmap);
                //        m.Textures.Insert(g_Lightmap_Index, g_Specular);

                //    }

                //    foreach (var tx in m.Textures)
                //    {
                //        //tx.Path = tx.Path.Replace("+", "").Replace("~", "");
                //        if (tx.Type != "g_DetailBumpmap")
                //            tx.Path = @"N:\FRPG\data\Model\map\m10\tex\PleaseDontCrash.tga";
                //    }

                //    m.Name = $"Material{xx}";

                //    xx++;
                //}

                //flver.GXLists.Clear();


                // Max 189
                // 90 fine
                // 140 fine
                // 160 fine
                // 165 fine
                // 166 CRASH
                // 170 CRASH
                // First 180 CRASH
                flver.Meshes = flver.Meshes.Skip(165).ToList();

                //var culprit = flver.Meshes[165];

                //foreach (var v in culprit.Vertices)
                //{
                //    //if (v.BoneIndices[0] != 0 || v.BoneIndices[1] != 0 || v.BoneIndices[2] != 0 || v.BoneIndices[3] != 0 ||
                //    //    v.BoneWeights[0] != 0 || v.BoneWeights[1] != 0 || v.BoneWeights[2] != 0 || v.BoneWeights[3] != 0 ||
                //    //    v.Colors[0].R != 1 || v.Colors[0].G != 1 || v.Colors[0].B != 1 || v.Colors[0].A != 1)
                //    //{
                //    //    Console.WriteLine("SDFLJSHDF");
                //    //}
                //    v.UVs[0] = new NVector3(0, 0, 0);
                //    v.UVs[1] = new NVector3(0, 0, 0);

                //    v.Position = new NVector3(0, 0, 0);
                //    v.Normal = NVector3.UnitY;
                //}

                flver.Materials = flver.Materials.Skip(165).ToList();

                flver.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\map\m10_02_00_00\m4100B2A10.flver");

                flver.Compression = DCX.Type.DCX_DFLT_10000_24_9;

                flver.Write(@"C:\Program Files (x86)\Steam\steamapps\common\DARK SOULS REMASTERED - Nightfall\map\m10_02_00_00\m4100B2A10.flver.dcx");

                Console.WriteLine("fatxat");
            }


            if (DebugTestButton("DEMONS SOULS TAE CONVERT"))
            {
                //var tae = TAE.Read(@"C:\RPCS3\dev_hdd0\disc\BLUS30443\PS3_GAME\USRDIR\chr\c0000\c0000-anibnd\Model\chr\c0000\tae\a00.tae");

                var taeFileNames = Directory.GetFiles(@"E:\DarkSoulsModding\_DESANIM\_TaeToDS1", "*.tae");



                foreach (var t in taeFileNames)
                {
                    var tae = TAE.Read(t);

                    var templateDS1 = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DS1.xml"));
                    var templateDES = TAE.Template.ReadXMLFile(System.IO.Path.Combine(new System.IO.FileInfo(typeof(_QuickDebug).Assembly.Location).DirectoryName, $@"Res\TAE.Template.DES.xml"));

                    tae.ApplyTemplate(templateDES);

                    tae.BigEndian = false;
                    tae.Format = TAE.TAEFormat.DS1;

                    tae.ChangeTemplateAfterLoading(templateDS1);

                    tae.Write($@"E:\DarkSoulsModding\_DESANIM\_TaeToDS1\out\{Path.GetFileNameWithoutExtension(t)}.tae");
                }

                Console.WriteLine("FATCAT");
            }

            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();

            if (DebugTestButton("DEMONS SOULS HKX CONVERT"))
            {
                //var tae = TAE.Read(@"C:\RPCS3\dev_hdd0\disc\BLUS30443\PS3_GAME\USRDIR\chr\c0000\c0000-anibnd\Model\chr\c0000\tae\a00.tae");

                DebugTest_RemapHK2010InterleavedAnims(@"E:\DarkSoulsModding\_DESANIM\_ToDS1");

                Console.WriteLine("FATCAT");
            }

            if (DebugTestButton("DEMONS SOULS HKX CONVERT NO RETARGET"))
            {
                //var tae = TAE.Read(@"C:\RPCS3\dev_hdd0\disc\BLUS30443\PS3_GAME\USRDIR\chr\c0000\c0000-anibnd\Model\chr\c0000\tae\a00.tae");

                DebugTest_StripExtraAnimMemeFromDespacitoHkx(@"E:\DarkSoulsModding\_DESANIM\_ToDS1");

                Console.WriteLine("FATCAT");
            }

            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();

            if (false && DebugTestButton("EXPORT CURRENT ANIMATION\n\n[ASSIMP TEST]"))
            {
                var a = Scene.MainModel?.AnimContainer?.CurrentAnimation?.data;
                return;
                if (a != null)
                {
                    SoulsAssetPipeline.AnimationExporting.AnimationExporter.ExportToFile(a, @"C:\Users\Green\OneDrive\Documents\SAP_ANIM_EXPORT_TEST.fbx", "fbx");
                }
                else
                {
                    ImguiOSD.DialogManager.DialogOK("CURRENT ANIMATION IS NULL", "CURRENT ANIMATION IS NULL");
                }

                Console.WriteLine("DFSDF");
            }

            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();

            if (false && DebugTestButton("SIBCAM TEST"))
            {
                var s = SIBCAM.Read(@"E:\Program Files (x86)\Steam\steamapps\common\Dark Souls Prepare to Die Edition\DATA\remo\scn150000-remobnd\cut0060\camera_win32.sibcam");

                Console.WriteLine("DFSDF");
            }

            if (false && DebugTestButton("REMO HKX TEST"))
            {
                var hkxTestPath = @"E:\Program Files (x86)\Steam\steamapps\common\Dark Souls Prepare to Die Edition\DATA\remo\scn180000-remobnd\cut0030\hkxwin32\a0030.hkx";
                HKX.HKAAnimationBinding hk_binding = null;
                HKX.HKASplineCompressedAnimation hk_anim = null;
                HKX.HKASkeleton hk_skeleton = null;

                var hkx = HKX.Read(hkxTestPath, HKX.HKXVariation.HKXDS1, false);

                foreach (var o in hkx.DataSection.Objects)
                {
                    if (o is HKX.HKASkeleton asSkeleton)
                        hk_skeleton = asSkeleton;
                    else if (o is HKX.HKAAnimationBinding asBinding)
                        hk_binding = asBinding;
                    else if (o is HKX.HKASplineCompressedAnimation asAnim)
                        hk_anim = asAnim;
                }

                Scene.MainModel.AnimContainer.ClearAnimations();
                Scene.MainModel.AnimContainer.Skeleton.LoadHKXSkeleton(hkx);

                var testIdleAnimThing = new NewHavokAnimation_SplineCompressed("a00_0000.hkx",
                    Scene.MainModel.AnimContainer.Skeleton, null, hk_binding, hk_anim, Scene.MainModel.AnimContainer, fileSize: -1);

                Scene.MainModel.AnimContainer.AddNewAnimation("a00_0000.hkx", testIdleAnimThing);

                Scene.MainModel.AnimContainer.ChangeToNewAnimation("a00_0000.hkx", animWeight: 1, startTime: 0, clearOldLayers: true);

                Scene.MainModel.IsRemoModel = true;
                Scene.MainModel.Name = "c0000_0000";

                Scene.MainModel.AnimContainer.ForcePlayAnim = true;

                Scene.MainModel.SkeletonFlver.RevertToReferencePose();

                Scene.MainModel.SkeletonFlver.MapToSkeleton(Scene.MainModel.AnimContainer.Skeleton, isRemo: true);
            }



            if (false && DebugTestButton("DS2 IMPORT TEST"))
            {
                LoadingTaskMan.DoLoadingTask(null, "DS2 IMPORT TEST", prog =>
                {
                    GameRoot.SoftInit(SoulsAssetPipeline.SoulsGames.DS2SOTFS);

                    var bndPath_ORIG = @"C:\Program Files (x86)\Steam\steamapps\common\Dark Souls II Scholar of the First Sin\Game\model\parts\head\hd_2021_m.bnd";
                    var bnd_ORIG = BND4.Read(bndPath_ORIG);



                    var bndPath = @"C:\Program Files (x86)\Steam\steamapps\common\Dark Souls II Scholar of the First Sin\Game\sap_test\model\parts\head\hd_2021_m.bnd";

                    var bndPath_BaseChr = @"C:\Program Files (x86)\Steam\steamapps\common\Dark Souls II Scholar of the First Sin\Game\model\chr\c0001.bnd";

                    var bnd_BaseChr = BND4.Read(bndPath_BaseChr);

                    var flver_BaseChr = FLVER2.Read(bnd_BaseChr.Files.First(x => x.Name.ToLower().EndsWith(".flv")).Bytes);


                    var flver_orig = FLVER2.Read(bnd_ORIG.Files.First(x => x.Name.ToLower().EndsWith(".flv")).Bytes);

                    var acb_orig = ACB.Read(bnd_ORIG.Files.First(x => x.Name.ToLower().EndsWith(".acb")).Bytes);



                    var fbx = @"E:\DarkSoulsModding\_FBX\DS2HelmDangel.FBX";
                    var settings = new FLVER2Importer.FLVER2ImportSettings()
                    {
                        AssetPath = fbx,
                        ConvertFromZUp = true,
                        SceneScale = 100,
                        FlverHeader = flver_orig.Header,
                        Game = SoulsAssetPipeline.SoulsGames.DS2,
                        RootNodeName = "Root",
                        SkeletonTransformsOverride = flver_orig.Bones,
                        //SceneCorrectMatrix = System.Numerics.Matrix4x4.CreateRotationY(SoulsAssetPipeline.SapMath.Pi),
                        //BoneNameRemapper = new Dictionary<string, string>
                        //{
                        //    { "Pelvis001", "Pelvis" },
                        //}
                    };

                    var importer = new FLVER2Importer();
                    var imp = importer.ImportFBX(fbx, settings);

                    var rootBone = imp.Flver.Bones.FindIndex(bn => bn.Name == "SMDImporter.Mesh.c1500");
                    if (rootBone >= 0)
                    {
                        //imp.Flver.Bones[rootBone].Rotation = new System.Numerics.Vector3(imp.Flver.Bones[rootBone].Rotation.X,
                        //    imp.Flver.Bones[rootBone].Rotation.Y + SoulsAssetPipeline.SapMath.Pi, imp.Flver.Bones[rootBone].Rotation.Z);
                    }

                    void AddMemeBone(string memeBoneName)
                    {
                        int flverLastRootBoneIndex = imp.Flver.Bones.FindLastIndex(b => b.ParentIndex == -1);
                        // Register this new bone as a sibling.
                        if (flverLastRootBoneIndex >= 0)
                            imp.Flver.Bones[flverLastRootBoneIndex].NextSiblingIndex = (short)imp.Flver.Bones.Count;
                        //imp.Flver.Bones.Add(new FLVER.Node()
                        //{
                        //    Name = memeBoneName,
                        //    Translation = System.Numerics.Vector3.Zero,
                        //    Rotation = System.Numerics.Vector3.Zero,
                        //    Scale = System.Numerics.Vector3.One,
                        //    BoundingBoxMin = new System.Numerics.Vector3(float.MaxValue),
                        //    BoundingBoxMax = new System.Numerics.Vector3(float.MinValue),
                        //    // Cross-register sibling from above.
                        //    PreviousSiblingIndex = (short)flverLastRootBoneIndex,
                        //    NextSiblingIndex = -1,
                        //    ParentIndex = -1,
                        //    ChildIndex = -1,
                        //    Unk3C = 1,
                        //});
                    }

                    //AddMemeBone($"{Path.GetFileNameWithoutExtension(bndPath).ToUpper()}");
                    //AddMemeBone($"{Path.GetFileNameWithoutExtension(bndPath).ToUpper()}_A");

                    //foreach (var m in imp.Flver.Materials)
                    //{
                    //    m.Name = m.Name.Replace("#", "");
                    //}



                    Scene.ClearScene();
                    lock (Scene._lock_ModelLoad_Draw)
                    {
                        var mdl = new Model(imp.Flver, false);
                        mdl.AnimContainer.ForcePlayAnim = true;
                        Scene.Models.Add(mdl);
                        var tpf = new TPF();
                        tpf.Textures.AddRange(imp.Textures);
                        TexturePool.AddTpf(tpf);
                        Scene.ForceTextureReloadImmediate();
                    }





                    bnd_ORIG.Files.Clear();

                    foreach (var t in imp.Textures)
                    {
                        var tpf = new TPF();
                        tpf.Textures.Add(t);
                        bnd_ORIG.Files.Add(new BinderFile(Binder.FileFlags.Flag1, bnd_ORIG.Files.Count, t.Name, tpf.Write()));
                    }

                    ////TESTING
                    //foreach (var m in imp.Flver.Meshes)
                    //{
                    //    foreach (var fs in m.FaceSets)
                    //    {
                    //        fs.Indices = fs.Indices.Select(x => x >= 65535 ? 0xFFFF : x).Take(65535).ToList();
                    //    }
                    //    m.Vertices = m.Vertices.Take(65535).ToList();
                    //}

                    bnd_ORIG.Files.Add(new BinderFile(Binder.FileFlags.Flag1, bnd_ORIG.Files.Count, $"{Path.GetFileNameWithoutExtension(bndPath)}.flv", imp.Flver.Write()));
                    //bnd_ORIG.Files.Add(new BinderFile(Binder.FileFlags.Flag1, bnd_ORIG.Files.Count, $"{Path.GetFileNameWithoutExtension(bndPath)}.acb", acb_orig.Write()));

                    if (File.Exists(bndPath) && !File.Exists(bndPath + ".bak"))
                    {
                        File.Copy(bndPath, bndPath + ".bak");
                    }

                    bnd_ORIG.Write(bndPath);



                    var hkxTestPath = @"E:\DarkSoulsModding\_DS2ANIM\DS2_PLAYER_TEST_ANIM.hkx";
                    HKX.HKAAnimationBinding hk_binding = null;
                    HKX.HKAInterleavedUncompressedAnimation hk_anim = null;
                    HKX.HKASkeleton hk_skeleton = null;

                    var hkx = HKX.Read(hkxTestPath, HKX.HKXVariation.HKXDS3, false);

                    foreach (var o in hkx.DataSection.Objects)
                    {
                        if (o is HKX.HKASkeleton asSkeleton)
                            hk_skeleton = asSkeleton;
                        else if (o is HKX.HKAAnimationBinding asBinding)
                            hk_binding = asBinding;
                        else if (o is HKX.HKAInterleavedUncompressedAnimation asAnim)
                            hk_anim = asAnim;
                    }

                    Scene.MainModel.AnimContainer.Skeleton.LoadHKXSkeleton(hkx);

                    var testIdleAnimThing = new NewHavokAnimation_InterleavedUncompressed("a00_00_0000.hkx",
                        Scene.MainModel.AnimContainer.Skeleton, null, hk_binding, hk_anim, Scene.MainModel.AnimContainer, fileSize: -1);

                    Scene.MainModel.AnimContainer.AddNewAnimation("a00_00_0000.hkx", testIdleAnimThing);

                    Scene.MainModel.AnimContainer.ChangeToNewAnimation("a00_00_0000.hkx", animWeight: 1, startTime: 0, clearOldLayers: true);

                    Scene.MainModel.AnimContainer.ForcePlayAnim = true;
                }, disableProgressBarByDefault: true, isUnimportant: true);


            }

            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();
            ImGui.Separator();

            if (DebugTestButton("Elden ring parts tae scan"))
            {
                var partsbnds = Directory.GetFiles(@"C:\Program Files (x86)\Steam\steamapps\common\ELDEN RING\Game\parts", "*.partsbnd.dcx")
                    .Where(p => !p.ToLowerInvariant().EndsWith("_l.partsbnd.dcx")).ToList();
                foreach (var p in partsbnds)
                {
                    var bnd = BND4.Read(p);
                    var anibndFileEntry = bnd.Files.FirstOrDefault(f => f.ID == 400);
                    if (anibndFileEntry != null)
                    {
                        var anibnd = BND4.Read(anibndFileEntry.Bytes);
                        foreach (var f in anibnd.Files)
                        {
                            if (f.Name.ToLowerInvariant().Contains(".anibnd"))
                                System.Diagnostics.Debug.WriteLine($"'{p}' has TAE");
                        }
                    }
                }

                Console.WriteLine("test");
            }

            if (false && DebugTestButton("SoulsAssetPipeline_Anim_Test"))
            {
                var boneDefaultTransforms = Scene.MainModel.AnimContainer.Skeleton.HkxSkeleton.ToDictionary(x => x.Name, x => x.RelativeReferenceTransform);
                var importSettings = new SoulsAssetPipeline.AnimationImporting.AnimationImporter.AnimationImportSettings
                {
                    SceneScale = 1,
                    ExistingBoneDefaults = boneDefaultTransforms,
                    ExistingHavokAnimationTemplate = Scene.MainModel.AnimContainer.CurrentAnimation.data,
                    ResampleToFramerate = 120,
                    RootMotionNodeName = "root",
                    FlipQuaternionHandedness = false,
                    //ConvertFromZUp = true,
                };

                var importedAnim = SoulsAssetPipeline.AnimationImporting.AnimationImporter.ImportFBX(
                    @"E:\DarkSoulsModding\_FBX_ANIM\meow_test.fbx", importSettings);

                string filePath_uncompressedXml = @"E:\DarkSoulsModding\_FBX_ANIM\meow_test.fbx.dsasimport.xml";
                string filePath_compressedHkx = @"E:\DarkSoulsModding\_FBX_ANIM\meow_test.fbx.dsasimport.hkx";

                var compressedHkx = importedAnim.WriteToSplineCompressedHKX2010Bytes(SplineCompressedAnimation.RotationQuantizationType.THREECOMP40, 0.001f, Main.Directory);

                //byte[] animData = File.ReadAllBytes(filePath_compressedHkx);
                zzz_DocumentManager.CurrentDocument.EditorScreen.FileContainer.AddNewHKX(Utils.GetFileNameWithoutAnyExtensions(Scene.MainModel.AnimContainer.CurrentAnimationName), compressedHkx, out byte[] dataForAnimContainer);
                zzz_DocumentManager.CurrentDocument.EditorScreen.Graph.ViewportInteractor.CurrentModel.AnimContainer.AddNewHKXToLoad(Scene.MainModel.AnimContainer.CurrentAnimationName, dataForAnimContainer);

                //importedFlver.WriteToHavok2010InterleavedUncompressedXML(@"C:\DarkSoulsModding\CUSTOM ANIM\c2570\ShieldBashVanilla.fbx.saptest.xml");

                lock (Scene._lock_ModelLoad_Draw)
                {
                    zzz_DocumentManager.CurrentDocument.EditorScreen.SelectNewAnimRef(zzz_DocumentManager.CurrentDocument.EditorScreen.SelectedTae, zzz_DocumentManager.CurrentDocument.EditorScreen.SelectedTaeAnim);
                    //var anim = new NewHavokAnimation(importedAnim, Scene.MainModel.AnimContainer.Skeleton, Scene.MainModel.AnimContainer);
                    //string animName = Scene.MainModel.AnimContainer.CurrentAnimationName;
                    //Scene.MainModel.AnimContainer.AddNewAnimation(animName, anim);
                    //Scene.MainModel.AnimContainer?.ClearAnimation();
                    //Scene.MainModel.AnimContainer.CurrentAnimationName = animName;
                    //Scene.MainModel.AnimContainer.ResetAll();
                    Main.TAE_EDITOR?.HardReset();
                }
                //Console.WriteLine("fatcat");
            }
        }




        private static void DebugTest_RemapHK2010InterleavedAnims(string dir)
        {
            var hkxs = Directory.GetFiles(dir, "*.hkx");

            HKX.HKASkeleton source_skeleton = null;
            HKX.HKASkeleton target_skeleton = null;

            foreach (var h in hkxs)
            {
                if (h.ToLower().EndsWith("sourceskeleton.hkx"))
                {
                    var hkx = HKX.Read(h);
                    foreach (var o in hkx.DataSection.Objects)
                    {
                        if (o is HKX.HKASkeleton asSkeleton)
                            source_skeleton = asSkeleton;
                    }
                }
                else if (h.ToLower().EndsWith("targetskeleton.hkx"))
                {
                    var hkx = HKX.Read(h);
                    foreach (var o in hkx.DataSection.Objects)
                    {
                        if (o is HKX.HKASkeleton asSkeleton)
                            target_skeleton = asSkeleton;
                    }
                }
            }

            var sourceTpose = source_skeleton.Transforms.GetArrayData().Elements.Select(tp => NewBlendableTransform.FromHKXTransform(tp)).ToList();
            var targetTpose = target_skeleton.Transforms.GetArrayData().Elements.Select(tp => NewBlendableTransform.FromHKXTransform(tp)).ToList();

            var targetBonesChildren = new List<List<int>>();
            var targetBonesTopOfHierarchy = new List<int>();

            var sourceBonesChildren = new List<List<int>>();
            var sourceBonesTopOfHierarchy = new List<int>();

            for (int i = 0; i < targetTpose.Count; i++)
            {
                targetBonesChildren.Add(new List<int>());
            }

            for (int i = 0; i < sourceTpose.Count; i++)
            {
                sourceBonesChildren.Add(new List<int>());
            }

            for (int i = 0; i < targetTpose.Count; i++)
            {
                var parent = target_skeleton.ParentIndices[i].data;
                if (parent >= 0)
                {
                    if (parent < targetTpose.Count)
                    {
                        if (!targetBonesChildren[parent].Contains(i))
                            targetBonesChildren[parent].Add(i);
                    }
                }
                else
                {
                    targetBonesTopOfHierarchy.Add(i);
                }
            }

            for (int i = 0; i < sourceTpose.Count; i++)
            {
                var parent = source_skeleton.ParentIndices[i].data;
                if (parent >= 0)
                {
                    if (parent < sourceTpose.Count)
                    {
                        if (!sourceBonesChildren[parent].Contains(i))
                            sourceBonesChildren[parent].Add(i);
                    }
                }
                else
                {
                    sourceBonesTopOfHierarchy.Add(i);
                }
            }

            foreach (var h in hkxs)
            {
                if (h.ToLower().EndsWith("sourceskeleton.hkx"))
                {
                    continue;
                }
                else if (h.ToLower().EndsWith("targetskeleton.hkx"))
                {
                    continue;
                }

                var hkx = HKX.Read(h);

                HKX.HKAAnimationBinding hk_binding = null;
                HKX.HKAInterleavedUncompressedAnimation hk_anim = null;
                HKX.HKADefaultAnimatedReferenceFrame hk_refFrame = null;

                foreach (var o in hkx.DataSection.Objects)
                {
                    if (o is HKX.HKAAnimationBinding asBinding)
                        hk_binding = asBinding;
                    else if (o is HKX.HKAInterleavedUncompressedAnimation asAnim)
                        hk_anim = asAnim;
                    else if (o is HKX.HKADefaultAnimatedReferenceFrame asRefFrame)
                        hk_refFrame = asRefFrame;
                }

                var targetBoneList = target_skeleton.Bones.GetArrayData().Elements.Select(b => b.Name.GetString()).ToList();



                var sourceRootMotionSamples = (hk_refFrame != null) ? hk_refFrame.ReferenceFrameSamples.GetArrayData().Elements.Select(rfs => rfs.Vector).ToList() : null;

                if (hk_anim == null)
                    continue;

                var a = new HavokAnimationData_InterleavedUncompressed("fatcat", source_skeleton, hk_refFrame, hk_binding, hk_anim);
                var targetBoneMapping = a.GetTransformTrackBoneNameMapping(targetBoneList);
                var thing = new SoulsAssetPipeline.AnimationImporting.ImportedAnimation();

                thing.Duration = hk_anim.Duration;
                thing.BlendHint = hk_binding.BlendHint;
                thing.FrameCount = (int)hk_anim.Transforms.Capacity / hk_anim.TransformTrackCount;
                thing.FrameDuration = (thing.Duration / thing.FrameCount);

                thing.HkxBoneIndexToTransformTrackMap = new int[targetBoneList.Count];
                thing.TransformTrackIndexToHkxBoneMap = new int[targetBoneList.Count];

                for (int i = 0; i < targetBoneList.Count; i++)
                {
                    thing.HkxBoneIndexToTransformTrackMap[i] = i;
                    thing.TransformTrackIndexToHkxBoneMap[i] = i;
                    thing.TransformTrackNames.Add(targetBoneList[i]);
                    thing.TransformTrackToBoneIndices.Add(targetBoneList[i], i);
                }

                for (int f = 0; f < thing.FrameCount; f++)
                {
                    var newFrame = new SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame();
                    if (sourceRootMotionSamples != null)
                    {
                        int rootMotionIndex = f % sourceRootMotionSamples.Count;

                        var sample = sourceRootMotionSamples[rootMotionIndex];

                        if (sourceRootMotionSamples.Count == 2)
                        {
                            if (hk_refFrame.Duration < 0.001f || thing.FrameDuration < 0.01f || thing.FrameDuration > 1f)
                                Console.WriteLine("DFSDF");
                            sample = (sourceRootMotionSamples[1] - sourceRootMotionSamples[0]) * ((f * thing.FrameDuration) / hk_refFrame.Duration);
                        }

                        newFrame.RootMotionRotation = sample.W;
                        newFrame.RootMotionTranslation = new System.Numerics.Vector3(
                            sample.X,
                            sample.Y,
                            sample.Z);
                    }

                    for (int i = 0; i < targetBoneList.Count; i++)
                    {
                        newFrame.BoneTransforms.Add(NewBlendableTransform.FromHKXTransform(target_skeleton.Transforms[i]));
                    }

                    thing.Frames.Add(newFrame);
                }

                var sourceTrackToBoneMap = hk_binding.TransformTrackToBoneIndices.GetArrayData().Elements.Select(bn => bn.data).ToList();
                var sourceBoneToTrackMap = new int[sourceTrackToBoneMap.Count];

                for (int i = 0; i < sourceBoneToTrackMap.Length; i++)
                {
                    sourceBoneToTrackMap[i] = -1;
                }

                for (int i = 0; i < sourceTrackToBoneMap.Count; i++)
                {
                    if (sourceTrackToBoneMap[i] >= 0)
                        sourceBoneToTrackMap[sourceTrackToBoneMap[i]] = i;
                }

                var sourceBoneNames = source_skeleton.Bones.GetArrayData().Elements.Select(bn => bn.Name.GetString()).ToList();

                var hotfixTrackIndex_R_Arm_Root = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_Arm_Root")];
                var hotfixTrackIndex_R_Clavicle = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_Clavicle")];
                var hotfixTrackIndex_R_UpperArm = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_UpperArm")];
                var hotfixTrackIndex_R_UpArmTwist = sourceBoneToTrackMap[sourceBoneNames.IndexOf("RUpArmTwist")];
                var hotfixTrackIndex_R_ForeTwist = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_ForeTwist")];
                var hotfixTrackIndex_R_Finger0 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_Finger0")];
                var hotfixTrackIndex_R_Finger1 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_Finger1")];
                var hotfixTrackIndex_R_Finger2 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_Finger2")];
                var hotfixTrackIndex_R_Finger3 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("R_Finger3")];

                var hotfixTrackIndex_L_Arm_Root = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_Arm_Root")];
                var hotfixTrackIndex_L_Clavicle = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_Clavicle")];
                var hotfixTrackIndex_L_UpperArm = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_UpperArm")];
                var hotfixTrackIndex_L_UpArmTwist = sourceBoneToTrackMap[sourceBoneNames.IndexOf("LUpArmTwist")];
                var hotfixTrackIndex_L_ForeTwist = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_ForeTwist")];
                var hotfixTrackIndex_L_Finger0 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_Finger0")];
                var hotfixTrackIndex_L_Finger1 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_Finger1")];
                var hotfixTrackIndex_L_Finger2 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_Finger2")];
                var hotfixTrackIndex_L_Finger3 = sourceBoneToTrackMap[sourceBoneNames.IndexOf("L_Finger3")];

                var sourceTransforms = hk_anim.Transforms.GetArrayData().Elements;

                foreach (var kvp in targetBoneMapping)
                {
                    int sourceTrackIndex = kvp.Key;



                    int targetBoneIndex = targetBoneList.IndexOf(kvp.Value);

                    int srcBoneIndex = hk_binding.TransformTrackToBoneIndices[sourceTrackIndex].data;

                    var targetBoneTransform = NewBlendableTransform.FromHKXTransform(target_skeleton.Transforms[targetBoneIndex]);
                    var sourceBoneTransform = NewBlendableTransform.FromHKXTransform(source_skeleton.Transforms[srcBoneIndex]);

                    for (int f = 0; f < thing.FrameCount; f++)
                    {
                        var srcTransform = NewBlendableTransform.FromHKXTransform(
                            sourceTransforms[((hk_anim.TransformTrackCount * f) + sourceTrackIndex)]);

                        if (sourceTrackIndex == hotfixTrackIndex_L_Clavicle)
                        {
                            var rootThing = NewBlendableTransform.FromHKXTransform(
                                sourceTransforms[((hk_anim.TransformTrackCount * f) + hotfixTrackIndex_L_Arm_Root)]);

                            //srcTransform.Rotation = srcTransform.Rotation * rootThing.Rotation;
                            //srcTransform.Translation = rootThing.Translation;

                            srcTransform = new NewBlendableTransform(srcTransform.GetMatrixUnnormalized() * rootThing.GetMatrixUnnormalized());
                        }
                        else if (sourceTrackIndex == hotfixTrackIndex_R_Clavicle)
                        {
                            var rootThing = NewBlendableTransform.FromHKXTransform(
                                sourceTransforms[((hk_anim.TransformTrackCount * f) + hotfixTrackIndex_R_Arm_Root)]);

                            //srcTransform.Rotation = srcTransform.Rotation * rootThing.Rotation;
                            //srcTransform.Translation = rootThing.Translation;

                            srcTransform = new NewBlendableTransform(srcTransform.GetMatrixUnnormalized() * rootThing.GetMatrixUnnormalized());
                        }
                        //else if (sourceTrackIndex == hotfixTrackIndex_R_UpArmTwist)
                        //{
                        //    srcTransform.Rotation = NQuaternion.CreateFromYawPitchRoll(MathHelper.PiOver2, 0, 0) * srcTransform.Rotation;
                        //}
                        //else if (sourceTrackIndex == hotfixTrackIndex_L_UpArmTwist)
                        //{
                        //    srcTransform.Rotation = NQuaternion.CreateFromYawPitchRoll(MathHelper.PiOver2, 0, 0) * srcTransform.Rotation;
                        //}
                        else if (sourceTrackIndex == hotfixTrackIndex_R_Finger2)
                        {
                            srcTransform = NewBlendableTransform.FromHKXTransform(
                                sourceTransforms[((hk_anim.TransformTrackCount * f) + hotfixTrackIndex_R_Finger3)]);
                        }
                        else if (sourceTrackIndex == hotfixTrackIndex_L_Finger2)
                        {
                            srcTransform = NewBlendableTransform.FromHKXTransform(
                                sourceTransforms[((hk_anim.TransformTrackCount * f) + hotfixTrackIndex_L_Finger3)]);
                        }

                        thing.Frames[f].BoneTransforms[targetBoneIndex] = srcTransform;// (srcTransform * NewBlendableTransform.Invert(sourceBoneTransform)) * targetBoneTransform;// NewBlendableTransform.ApplyFromToDeltaTransform(srcTransform, sourceTpose[srcBoneIndex], targetTpose[targetBoneIndex]);
                    }
                }

                for (int t = 0; t < targetBoneList.Count; t++)
                {
                    for (int f = 1; f < thing.FrameCount; f++)
                    {
                        var tr = thing.Frames[f].BoneTransforms[t];
                        tr.Rotation = NQuaternion.Normalize(tr.Rotation);
                        thing.Frames[f].BoneTransforms[t] = tr;
                    }
                }

                for (int t = 0; t < targetBoneList.Count; t++)
                {
                    for (int f = 1; f < thing.FrameCount; f++)
                    {
                        // Use dot product to see how drastically this transform rotated in the span of 1 frame.
                        var dot = NQuaternion.Dot(thing.Frames[f - 1].BoneTransforms[t].Rotation, thing.Frames[f].BoneTransforms[t].Rotation);
                        // If it did more than a 90 degree turn in a single frame, it's just flipping
                        // around backwards and we need to flip it back lol
                        if (dot < -0.5)
                        {
                            var tr = thing.Frames[f].BoneTransforms[t];
                            tr.Rotation = NQuaternion.Normalize(-tr.Rotation);
                            thing.Frames[f].BoneTransforms[t] = tr;
                        }
                    }
                }

                string shortHkxName = Path.GetFileNameWithoutExtension(h);
                string outDir = dir + "\\retargeted";
                if (!Directory.Exists(outDir))
                    Directory.CreateDirectory(outDir);

                byte[] hkxFinalBytes = thing.WriteToSplineCompressedHKX2010Bytes(SplineCompressedAnimation.RotationQuantizationType.THREECOMP40, 0.001f, Main.Directory);

                File.WriteAllBytes($@"{outDir}\{shortHkxName}.hkx", hkxFinalBytes);
            }

            Console.WriteLine("FATCAT");
        }

        private static void DebugTest_StripExtraAnimMemeFromDespacitoHkx(string dir)
        {
            var hkxs = Directory.GetFiles(dir, "*.hkx");

            HKX.HKASkeleton skeleton = null;

            foreach (var h in hkxs)
            {
                if (h.ToLower().EndsWith("skeleton.hkx"))
                {
                    var hkx = HKX.Read(h);
                    foreach (var o in hkx.DataSection.Objects)
                    {
                        if (o is HKX.HKASkeleton asSkeleton)
                            skeleton = asSkeleton;
                    }
                }
            }

            var targetBonesChildren = new List<List<int>>();
            var targetBonesTopOfHierarchy = new List<int>();

            var sourceBonesChildren = new List<List<int>>();
            var sourceBonesTopOfHierarchy = new List<int>();

            foreach (var h in hkxs)
            {
                if (h.ToLower().EndsWith("sourceskeleton.hkx"))
                {
                    continue;
                }
                else if (h.ToLower().EndsWith("targetskeleton.hkx"))
                {
                    continue;
                }

                var hkx = HKX.Read(h);

                HKX.HKAAnimationBinding hk_binding = null;
                HKX.HKAInterleavedUncompressedAnimation hk_anim = null;
                HKX.HKADefaultAnimatedReferenceFrame hk_refFrame = null;

                foreach (var o in hkx.DataSection.Objects)
                {
                    if (o is HKX.HKAAnimationBinding asBinding)
                        hk_binding = asBinding;
                    else if (o is HKX.HKAInterleavedUncompressedAnimation asAnim)
                        hk_anim = asAnim;
                    else if (o is HKX.HKADefaultAnimatedReferenceFrame asRefFrame)
                        hk_refFrame = asRefFrame;
                }

                var targetBoneList = skeleton.Bones.GetArrayData().Elements.Select(b => b.Name.GetString()).ToList();



                var sourceRootMotionSamples = (hk_refFrame != null) ? hk_refFrame.ReferenceFrameSamples.GetArrayData().Elements.Select(rfs => rfs.Vector).ToList() : null;

                if (hk_anim == null)
                    continue;

                var a = new HavokAnimationData_InterleavedUncompressed("fatcat", skeleton, hk_refFrame, hk_binding, hk_anim);
                var targetBoneMapping = a.GetTransformTrackBoneNameMapping(targetBoneList);
                var thing = new SoulsAssetPipeline.AnimationImporting.ImportedAnimation();

                thing.Duration = hk_anim.Duration;
                thing.BlendHint = hk_binding.BlendHint;
                thing.FrameCount = (int)hk_anim.Transforms.Capacity / hk_anim.TransformTrackCount;
                thing.FrameDuration = (thing.Duration / thing.FrameCount);

                thing.HkxBoneIndexToTransformTrackMap = new int[targetBoneList.Count];
                thing.TransformTrackIndexToHkxBoneMap = new int[targetBoneList.Count];

                for (int i = 0; i < targetBoneList.Count; i++)
                {
                    thing.HkxBoneIndexToTransformTrackMap[i] = i;
                    thing.TransformTrackIndexToHkxBoneMap[i] = i;
                    thing.TransformTrackNames.Add(targetBoneList[i]);
                    thing.TransformTrackToBoneIndices.Add(targetBoneList[i], i);
                }

                for (int f = 0; f < thing.FrameCount; f++)
                {
                    var newFrame = new SoulsAssetPipeline.AnimationImporting.ImportedAnimation.Frame();
                    if (sourceRootMotionSamples != null)
                    {
                        int rootMotionIndex = f % sourceRootMotionSamples.Count;

                        var sample = sourceRootMotionSamples[rootMotionIndex];

                        if (sourceRootMotionSamples.Count == 2)
                        {
                            if (hk_refFrame.Duration < 0.001f || thing.FrameDuration < 0.01f || thing.FrameDuration > 1f)
                                Console.WriteLine("DFSDF");
                            sample = (sourceRootMotionSamples[1] - sourceRootMotionSamples[0]) * ((f * thing.FrameDuration) / hk_refFrame.Duration);
                        }

                        newFrame.RootMotionRotation = sample.W;
                        newFrame.RootMotionTranslation = new System.Numerics.Vector3(
                            sample.X,
                            sample.Y,
                            sample.Z);
                    }



                    for (int i = 0; i < targetBoneList.Count; i++)
                    {
                        newFrame.BoneTransforms.Add(a.GetTransformOnFrameByBone(i, f, false));
                    }

                    thing.Frames.Add(newFrame);
                }

                string shortHkxName = Path.GetFileNameWithoutExtension(h);
                string outDir = dir + "\\stripped";
                if (!Directory.Exists(outDir))
                    Directory.CreateDirectory(outDir);

                byte[] hkxFinalBytes = thing.WriteToSplineCompressedHKX2010Bytes(SplineCompressedAnimation.RotationQuantizationType.THREECOMP40, 0.001f, Main.Directory);

                File.WriteAllBytes($@"{outDir}\{shortHkxName}.hkx", hkxFinalBytes);
            }

            Console.WriteLine("FATCAT");
        }

        private enum DebugValType
        {
            Int,
            Float,
            Bool,
            String
        };

        private static Dictionary<string, int> debugValFields_Int = new Dictionary<string, int>();
        private static Dictionary<string, float> debugValFields_Float = new Dictionary<string, float>();
        private static Dictionary<string, bool> debugValFields_Bool = new Dictionary<string, bool>();
        private static Dictionary<string, string> debugValFields_String = new Dictionary<string, string>();

        private static int UpdateInt(string key, string dispName, int defaultValue = 0)
        {
            var dict = debugValFields_Int;

            if (!dict.ContainsKey(key))
                dict.Add(key, defaultValue);

            var curVal = dict[key];
            ImGui.InputInt($"{dispName}##{key}", ref curVal);
            dict[key] = curVal;

            return curVal;
        }

        private static float UpdateFloat(string key, string dispName, float defaultValue = 0)
        {
            var dict = debugValFields_Float;

            if (!dict.ContainsKey(key))
                dict.Add(key, defaultValue);

            var curVal = dict[key];
            ImGui.InputFloat($"{dispName}##{key}", ref curVal);
            dict[key] = curVal;

            return curVal;
        }

        private static bool UpdateBool(string key, string dispName, bool defaultValue = false)
        {
            var dict = debugValFields_Bool;

            if (!dict.ContainsKey(key))
                dict.Add(key, defaultValue);

            var curVal = dict[key];
            ImGui.Checkbox($"{dispName}##{key}", ref curVal);
            dict[key] = curVal;

            return curVal;
        }

        private static string UpdateString(string key, string dispName, string defaultValue = "", uint maxStrLength = 128)
        {
            var dict = debugValFields_String;

            if (!dict.ContainsKey(key))
                dict.Add(key, defaultValue);

            var curVal = dict[key];
            ImGui.InputText($"{dispName}##{key}", ref curVal, maxStrLength);
            dict[key] = curVal;

            return curVal;
        }

        private static int GetInt(string key)
        {
            var dict = debugValFields_Int;
            return dict.ContainsKey(key) ? dict[key] : 0;
        }

        private static float GetFloat(string key)
        {
            var dict = debugValFields_Float;
            return dict.ContainsKey(key) ? dict[key] : 0;
        }

        private static bool GetBool(string key)
        {
            var dict = debugValFields_Bool;
            return dict.ContainsKey(key) ? dict[key] : false;
        }

        private static string GetString(string key)
        {
            var dict = debugValFields_String;
            return dict.ContainsKey(key) ? dict[key] : "";
        }

        private static bool DebugTestButton(string name)
        {
            ImGui.Button("TEST: " + name);
            return ImGui.IsItemClicked();
        }
    }
}
